#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Status.ttypes
import ErrorCodes.ttypes
import Types.ttypes
import Exprs.ttypes
import CatalogObjects.ttypes
import Descriptors.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import DataSinks.ttypes
import Results.ttypes
import RuntimeProfile.ttypes
import ImpalaService.ttypes
import Data.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TParquetFallbackSchemaResolution:
  POSITION = 0
  NAME = 1

  _VALUES_TO_NAMES = {
    0: "POSITION",
    1: "NAME",
  }

  _NAMES_TO_VALUES = {
    "POSITION": 0,
    "NAME": 1,
  }

class TParquetArrayResolution:
  THREE_LEVEL = 0
  TWO_LEVEL = 1
  TWO_LEVEL_THEN_THREE_LEVEL = 2

  _VALUES_TO_NAMES = {
    0: "THREE_LEVEL",
    1: "TWO_LEVEL",
    2: "TWO_LEVEL_THEN_THREE_LEVEL",
  }

  _NAMES_TO_VALUES = {
    "THREE_LEVEL": 0,
    "TWO_LEVEL": 1,
    "TWO_LEVEL_THEN_THREE_LEVEL": 2,
  }

class TJoinDistributionMode:
  BROADCAST = 0
  SHUFFLE = 1

  _VALUES_TO_NAMES = {
    0: "BROADCAST",
    1: "SHUFFLE",
  }

  _NAMES_TO_VALUES = {
    "BROADCAST": 0,
    "SHUFFLE": 1,
  }

class TSessionType:
  BEESWAX = 0
  HIVESERVER2 = 1

  _VALUES_TO_NAMES = {
    0: "BEESWAX",
    1: "HIVESERVER2",
  }

  _NAMES_TO_VALUES = {
    "BEESWAX": 0,
    "HIVESERVER2": 1,
  }

class ImpalaInternalServiceVersion:
  V1 = 0

  _VALUES_TO_NAMES = {
    0: "V1",
  }

  _NAMES_TO_VALUES = {
    "V1": 0,
  }


class TQueryOptions:
  """
  Attributes:
   - abort_on_error
   - max_errors
   - disable_codegen
   - batch_size
   - num_nodes
   - max_scan_range_length
   - num_scanner_threads
   - max_io_buffers
   - allow_unsupported_formats
   - default_order_by_limit
   - debug_action
   - mem_limit
   - abort_on_default_limit_exceeded
   - compression_codec
   - hbase_caching
   - hbase_cache_blocks
   - parquet_file_size
   - explain_level
   - sync_ddl
   - request_pool
   - v_cpu_cores
   - reservation_request_timeout
   - disable_cached_reads
   - disable_outermost_topn
   - rm_initial_mem
   - query_timeout_s
   - buffer_pool_limit
   - appx_count_distinct
   - disable_unsafe_spills
   - seq_compression_mode
   - exec_single_node_rows_threshold
   - optimize_partition_key_scans
   - replica_preference
   - schedule_random_replica
   - scan_node_codegen_threshold
   - disable_streaming_preaggregations
   - runtime_filter_mode
   - runtime_bloom_filter_size
   - runtime_filter_wait_time_ms
   - disable_row_runtime_filtering
   - max_num_runtime_filters
   - parquet_annotate_strings_utf8
   - parquet_fallback_schema_resolution
   - mt_dop
   - s3_skip_insert_staging
   - runtime_filter_min_size
   - runtime_filter_max_size
   - prefetch_mode
   - strict_mode
   - scratch_limit
   - enable_expr_rewrites
   - decimal_v2
   - parquet_dictionary_filtering
   - parquet_array_resolution
   - parquet_read_statistics
   - default_join_distribution_mode
   - disable_codegen_rows_threshold
   - default_spillable_buffer_size
   - min_spillable_buffer_size
   - max_row_size
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'abort_on_error', None, False, ), # 1
    (2, TType.I32, 'max_errors', None, 100, ), # 2
    (3, TType.BOOL, 'disable_codegen', None, False, ), # 3
    (4, TType.I32, 'batch_size', None, 0, ), # 4
    (5, TType.I32, 'num_nodes', None, 0, ), # 5
    (6, TType.I64, 'max_scan_range_length', None, 0, ), # 6
    (7, TType.I32, 'num_scanner_threads', None, 0, ), # 7
    (8, TType.I32, 'max_io_buffers', None, 0, ), # 8
    (9, TType.BOOL, 'allow_unsupported_formats', None, False, ), # 9
    (10, TType.I64, 'default_order_by_limit', None, -1, ), # 10
    (11, TType.STRING, 'debug_action', None, "", ), # 11
    (12, TType.I64, 'mem_limit', None, 0, ), # 12
    (13, TType.BOOL, 'abort_on_default_limit_exceeded', None, False, ), # 13
    (14, TType.I32, 'compression_codec', None, None, ), # 14
    (15, TType.I32, 'hbase_caching', None, 0, ), # 15
    (16, TType.BOOL, 'hbase_cache_blocks', None, False, ), # 16
    (17, TType.I64, 'parquet_file_size', None, 0, ), # 17
    (18, TType.I32, 'explain_level', None,     1, ), # 18
    (19, TType.BOOL, 'sync_ddl', None, False, ), # 19
    (20, TType.STRING, 'request_pool', None, None, ), # 20
    (21, TType.I16, 'v_cpu_cores', None, None, ), # 21
    (22, TType.I64, 'reservation_request_timeout', None, None, ), # 22
    (23, TType.BOOL, 'disable_cached_reads', None, False, ), # 23
    (24, TType.BOOL, 'disable_outermost_topn', None, False, ), # 24
    (25, TType.I64, 'rm_initial_mem', None, 0, ), # 25
    (26, TType.I32, 'query_timeout_s', None, 0, ), # 26
    (27, TType.I64, 'buffer_pool_limit', None, None, ), # 27
    (28, TType.BOOL, 'appx_count_distinct', None, False, ), # 28
    (29, TType.BOOL, 'disable_unsafe_spills', None, False, ), # 29
    (30, TType.I32, 'seq_compression_mode', None, None, ), # 30
    (31, TType.I32, 'exec_single_node_rows_threshold', None, 100, ), # 31
    (32, TType.BOOL, 'optimize_partition_key_scans', None, False, ), # 32
    (33, TType.I32, 'replica_preference', None,     0, ), # 33
    (34, TType.BOOL, 'schedule_random_replica', None, False, ), # 34
    (35, TType.I64, 'scan_node_codegen_threshold', None, 1800000, ), # 35
    (36, TType.BOOL, 'disable_streaming_preaggregations', None, False, ), # 36
    (37, TType.I32, 'runtime_filter_mode', None,     2, ), # 37
    (38, TType.I32, 'runtime_bloom_filter_size', None, 1048576, ), # 38
    (39, TType.I32, 'runtime_filter_wait_time_ms', None, 0, ), # 39
    (40, TType.BOOL, 'disable_row_runtime_filtering', None, False, ), # 40
    (41, TType.I32, 'max_num_runtime_filters', None, 10, ), # 41
    (42, TType.BOOL, 'parquet_annotate_strings_utf8', None, False, ), # 42
    (43, TType.I32, 'parquet_fallback_schema_resolution', None,     0, ), # 43
    (44, TType.I32, 'mt_dop', None, None, ), # 44
    (45, TType.BOOL, 's3_skip_insert_staging', None, True, ), # 45
    (46, TType.I32, 'runtime_filter_min_size', None, 1048576, ), # 46
    (47, TType.I32, 'runtime_filter_max_size', None, 16777216, ), # 47
    (48, TType.I32, 'prefetch_mode', None,     1, ), # 48
    (49, TType.BOOL, 'strict_mode', None, False, ), # 49
    (50, TType.I64, 'scratch_limit', None, -1, ), # 50
    (51, TType.BOOL, 'enable_expr_rewrites', None, True, ), # 51
    (52, TType.BOOL, 'decimal_v2', None, False, ), # 52
    (53, TType.BOOL, 'parquet_dictionary_filtering', None, True, ), # 53
    (54, TType.I32, 'parquet_array_resolution', None,     2, ), # 54
    (55, TType.BOOL, 'parquet_read_statistics', None, True, ), # 55
    (56, TType.I32, 'default_join_distribution_mode', None,     0, ), # 56
    (57, TType.I32, 'disable_codegen_rows_threshold', None, 50000, ), # 57
    (58, TType.I64, 'default_spillable_buffer_size', None, 2097152, ), # 58
    (59, TType.I64, 'min_spillable_buffer_size', None, 65536, ), # 59
    (60, TType.I64, 'max_row_size', None, 524288, ), # 60
  )

  def __init__(self, abort_on_error=thrift_spec[1][4], max_errors=thrift_spec[2][4], disable_codegen=thrift_spec[3][4], batch_size=thrift_spec[4][4], num_nodes=thrift_spec[5][4], max_scan_range_length=thrift_spec[6][4], num_scanner_threads=thrift_spec[7][4], max_io_buffers=thrift_spec[8][4], allow_unsupported_formats=thrift_spec[9][4], default_order_by_limit=thrift_spec[10][4], debug_action=thrift_spec[11][4], mem_limit=thrift_spec[12][4], abort_on_default_limit_exceeded=thrift_spec[13][4], compression_codec=None, hbase_caching=thrift_spec[15][4], hbase_cache_blocks=thrift_spec[16][4], parquet_file_size=thrift_spec[17][4], explain_level=thrift_spec[18][4], sync_ddl=thrift_spec[19][4], request_pool=None, v_cpu_cores=None, reservation_request_timeout=None, disable_cached_reads=thrift_spec[23][4], disable_outermost_topn=thrift_spec[24][4], rm_initial_mem=thrift_spec[25][4], query_timeout_s=thrift_spec[26][4], buffer_pool_limit=None, appx_count_distinct=thrift_spec[28][4], disable_unsafe_spills=thrift_spec[29][4], seq_compression_mode=None, exec_single_node_rows_threshold=thrift_spec[31][4], optimize_partition_key_scans=thrift_spec[32][4], replica_preference=thrift_spec[33][4], schedule_random_replica=thrift_spec[34][4], scan_node_codegen_threshold=thrift_spec[35][4], disable_streaming_preaggregations=thrift_spec[36][4], runtime_filter_mode=thrift_spec[37][4], runtime_bloom_filter_size=thrift_spec[38][4], runtime_filter_wait_time_ms=thrift_spec[39][4], disable_row_runtime_filtering=thrift_spec[40][4], max_num_runtime_filters=thrift_spec[41][4], parquet_annotate_strings_utf8=thrift_spec[42][4], parquet_fallback_schema_resolution=thrift_spec[43][4], mt_dop=None, s3_skip_insert_staging=thrift_spec[45][4], runtime_filter_min_size=thrift_spec[46][4], runtime_filter_max_size=thrift_spec[47][4], prefetch_mode=thrift_spec[48][4], strict_mode=thrift_spec[49][4], scratch_limit=thrift_spec[50][4], enable_expr_rewrites=thrift_spec[51][4], decimal_v2=thrift_spec[52][4], parquet_dictionary_filtering=thrift_spec[53][4], parquet_array_resolution=thrift_spec[54][4], parquet_read_statistics=thrift_spec[55][4], default_join_distribution_mode=thrift_spec[56][4], disable_codegen_rows_threshold=thrift_spec[57][4], default_spillable_buffer_size=thrift_spec[58][4], min_spillable_buffer_size=thrift_spec[59][4], max_row_size=thrift_spec[60][4],):
    self.abort_on_error = abort_on_error
    self.max_errors = max_errors
    self.disable_codegen = disable_codegen
    self.batch_size = batch_size
    self.num_nodes = num_nodes
    self.max_scan_range_length = max_scan_range_length
    self.num_scanner_threads = num_scanner_threads
    self.max_io_buffers = max_io_buffers
    self.allow_unsupported_formats = allow_unsupported_formats
    self.default_order_by_limit = default_order_by_limit
    self.debug_action = debug_action
    self.mem_limit = mem_limit
    self.abort_on_default_limit_exceeded = abort_on_default_limit_exceeded
    self.compression_codec = compression_codec
    self.hbase_caching = hbase_caching
    self.hbase_cache_blocks = hbase_cache_blocks
    self.parquet_file_size = parquet_file_size
    self.explain_level = explain_level
    self.sync_ddl = sync_ddl
    self.request_pool = request_pool
    self.v_cpu_cores = v_cpu_cores
    self.reservation_request_timeout = reservation_request_timeout
    self.disable_cached_reads = disable_cached_reads
    self.disable_outermost_topn = disable_outermost_topn
    self.rm_initial_mem = rm_initial_mem
    self.query_timeout_s = query_timeout_s
    self.buffer_pool_limit = buffer_pool_limit
    self.appx_count_distinct = appx_count_distinct
    self.disable_unsafe_spills = disable_unsafe_spills
    self.seq_compression_mode = seq_compression_mode
    self.exec_single_node_rows_threshold = exec_single_node_rows_threshold
    self.optimize_partition_key_scans = optimize_partition_key_scans
    self.replica_preference = replica_preference
    self.schedule_random_replica = schedule_random_replica
    self.scan_node_codegen_threshold = scan_node_codegen_threshold
    self.disable_streaming_preaggregations = disable_streaming_preaggregations
    self.runtime_filter_mode = runtime_filter_mode
    self.runtime_bloom_filter_size = runtime_bloom_filter_size
    self.runtime_filter_wait_time_ms = runtime_filter_wait_time_ms
    self.disable_row_runtime_filtering = disable_row_runtime_filtering
    self.max_num_runtime_filters = max_num_runtime_filters
    self.parquet_annotate_strings_utf8 = parquet_annotate_strings_utf8
    self.parquet_fallback_schema_resolution = parquet_fallback_schema_resolution
    self.mt_dop = mt_dop
    self.s3_skip_insert_staging = s3_skip_insert_staging
    self.runtime_filter_min_size = runtime_filter_min_size
    self.runtime_filter_max_size = runtime_filter_max_size
    self.prefetch_mode = prefetch_mode
    self.strict_mode = strict_mode
    self.scratch_limit = scratch_limit
    self.enable_expr_rewrites = enable_expr_rewrites
    self.decimal_v2 = decimal_v2
    self.parquet_dictionary_filtering = parquet_dictionary_filtering
    self.parquet_array_resolution = parquet_array_resolution
    self.parquet_read_statistics = parquet_read_statistics
    self.default_join_distribution_mode = default_join_distribution_mode
    self.disable_codegen_rows_threshold = disable_codegen_rows_threshold
    self.default_spillable_buffer_size = default_spillable_buffer_size
    self.min_spillable_buffer_size = min_spillable_buffer_size
    self.max_row_size = max_row_size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.abort_on_error = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max_errors = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.disable_codegen = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.batch_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.num_nodes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.max_scan_range_length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.num_scanner_threads = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.max_io_buffers = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.allow_unsupported_formats = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.default_order_by_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.debug_action = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.mem_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.abort_on_default_limit_exceeded = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.compression_codec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I32:
          self.hbase_caching = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BOOL:
          self.hbase_cache_blocks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.parquet_file_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I32:
          self.explain_level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.BOOL:
          self.sync_ddl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.request_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.I16:
          self.v_cpu_cores = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.I64:
          self.reservation_request_timeout = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.BOOL:
          self.disable_cached_reads = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.BOOL:
          self.disable_outermost_topn = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.I64:
          self.rm_initial_mem = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.I32:
          self.query_timeout_s = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.I64:
          self.buffer_pool_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.BOOL:
          self.appx_count_distinct = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.BOOL:
          self.disable_unsafe_spills = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.I32:
          self.seq_compression_mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 31:
        if ftype == TType.I32:
          self.exec_single_node_rows_threshold = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 32:
        if ftype == TType.BOOL:
          self.optimize_partition_key_scans = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 33:
        if ftype == TType.I32:
          self.replica_preference = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 34:
        if ftype == TType.BOOL:
          self.schedule_random_replica = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 35:
        if ftype == TType.I64:
          self.scan_node_codegen_threshold = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 36:
        if ftype == TType.BOOL:
          self.disable_streaming_preaggregations = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 37:
        if ftype == TType.I32:
          self.runtime_filter_mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 38:
        if ftype == TType.I32:
          self.runtime_bloom_filter_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 39:
        if ftype == TType.I32:
          self.runtime_filter_wait_time_ms = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 40:
        if ftype == TType.BOOL:
          self.disable_row_runtime_filtering = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 41:
        if ftype == TType.I32:
          self.max_num_runtime_filters = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 42:
        if ftype == TType.BOOL:
          self.parquet_annotate_strings_utf8 = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 43:
        if ftype == TType.I32:
          self.parquet_fallback_schema_resolution = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 44:
        if ftype == TType.I32:
          self.mt_dop = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 45:
        if ftype == TType.BOOL:
          self.s3_skip_insert_staging = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 46:
        if ftype == TType.I32:
          self.runtime_filter_min_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 47:
        if ftype == TType.I32:
          self.runtime_filter_max_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 48:
        if ftype == TType.I32:
          self.prefetch_mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 49:
        if ftype == TType.BOOL:
          self.strict_mode = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 50:
        if ftype == TType.I64:
          self.scratch_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 51:
        if ftype == TType.BOOL:
          self.enable_expr_rewrites = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 52:
        if ftype == TType.BOOL:
          self.decimal_v2 = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 53:
        if ftype == TType.BOOL:
          self.parquet_dictionary_filtering = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 54:
        if ftype == TType.I32:
          self.parquet_array_resolution = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 55:
        if ftype == TType.BOOL:
          self.parquet_read_statistics = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 56:
        if ftype == TType.I32:
          self.default_join_distribution_mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 57:
        if ftype == TType.I32:
          self.disable_codegen_rows_threshold = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 58:
        if ftype == TType.I64:
          self.default_spillable_buffer_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 59:
        if ftype == TType.I64:
          self.min_spillable_buffer_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 60:
        if ftype == TType.I64:
          self.max_row_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryOptions')
    if self.abort_on_error is not None:
      oprot.writeFieldBegin('abort_on_error', TType.BOOL, 1)
      oprot.writeBool(self.abort_on_error)
      oprot.writeFieldEnd()
    if self.max_errors is not None:
      oprot.writeFieldBegin('max_errors', TType.I32, 2)
      oprot.writeI32(self.max_errors)
      oprot.writeFieldEnd()
    if self.disable_codegen is not None:
      oprot.writeFieldBegin('disable_codegen', TType.BOOL, 3)
      oprot.writeBool(self.disable_codegen)
      oprot.writeFieldEnd()
    if self.batch_size is not None:
      oprot.writeFieldBegin('batch_size', TType.I32, 4)
      oprot.writeI32(self.batch_size)
      oprot.writeFieldEnd()
    if self.num_nodes is not None:
      oprot.writeFieldBegin('num_nodes', TType.I32, 5)
      oprot.writeI32(self.num_nodes)
      oprot.writeFieldEnd()
    if self.max_scan_range_length is not None:
      oprot.writeFieldBegin('max_scan_range_length', TType.I64, 6)
      oprot.writeI64(self.max_scan_range_length)
      oprot.writeFieldEnd()
    if self.num_scanner_threads is not None:
      oprot.writeFieldBegin('num_scanner_threads', TType.I32, 7)
      oprot.writeI32(self.num_scanner_threads)
      oprot.writeFieldEnd()
    if self.max_io_buffers is not None:
      oprot.writeFieldBegin('max_io_buffers', TType.I32, 8)
      oprot.writeI32(self.max_io_buffers)
      oprot.writeFieldEnd()
    if self.allow_unsupported_formats is not None:
      oprot.writeFieldBegin('allow_unsupported_formats', TType.BOOL, 9)
      oprot.writeBool(self.allow_unsupported_formats)
      oprot.writeFieldEnd()
    if self.default_order_by_limit is not None:
      oprot.writeFieldBegin('default_order_by_limit', TType.I64, 10)
      oprot.writeI64(self.default_order_by_limit)
      oprot.writeFieldEnd()
    if self.debug_action is not None:
      oprot.writeFieldBegin('debug_action', TType.STRING, 11)
      oprot.writeString(self.debug_action)
      oprot.writeFieldEnd()
    if self.mem_limit is not None:
      oprot.writeFieldBegin('mem_limit', TType.I64, 12)
      oprot.writeI64(self.mem_limit)
      oprot.writeFieldEnd()
    if self.abort_on_default_limit_exceeded is not None:
      oprot.writeFieldBegin('abort_on_default_limit_exceeded', TType.BOOL, 13)
      oprot.writeBool(self.abort_on_default_limit_exceeded)
      oprot.writeFieldEnd()
    if self.compression_codec is not None:
      oprot.writeFieldBegin('compression_codec', TType.I32, 14)
      oprot.writeI32(self.compression_codec)
      oprot.writeFieldEnd()
    if self.hbase_caching is not None:
      oprot.writeFieldBegin('hbase_caching', TType.I32, 15)
      oprot.writeI32(self.hbase_caching)
      oprot.writeFieldEnd()
    if self.hbase_cache_blocks is not None:
      oprot.writeFieldBegin('hbase_cache_blocks', TType.BOOL, 16)
      oprot.writeBool(self.hbase_cache_blocks)
      oprot.writeFieldEnd()
    if self.parquet_file_size is not None:
      oprot.writeFieldBegin('parquet_file_size', TType.I64, 17)
      oprot.writeI64(self.parquet_file_size)
      oprot.writeFieldEnd()
    if self.explain_level is not None:
      oprot.writeFieldBegin('explain_level', TType.I32, 18)
      oprot.writeI32(self.explain_level)
      oprot.writeFieldEnd()
    if self.sync_ddl is not None:
      oprot.writeFieldBegin('sync_ddl', TType.BOOL, 19)
      oprot.writeBool(self.sync_ddl)
      oprot.writeFieldEnd()
    if self.request_pool is not None:
      oprot.writeFieldBegin('request_pool', TType.STRING, 20)
      oprot.writeString(self.request_pool)
      oprot.writeFieldEnd()
    if self.v_cpu_cores is not None:
      oprot.writeFieldBegin('v_cpu_cores', TType.I16, 21)
      oprot.writeI16(self.v_cpu_cores)
      oprot.writeFieldEnd()
    if self.reservation_request_timeout is not None:
      oprot.writeFieldBegin('reservation_request_timeout', TType.I64, 22)
      oprot.writeI64(self.reservation_request_timeout)
      oprot.writeFieldEnd()
    if self.disable_cached_reads is not None:
      oprot.writeFieldBegin('disable_cached_reads', TType.BOOL, 23)
      oprot.writeBool(self.disable_cached_reads)
      oprot.writeFieldEnd()
    if self.disable_outermost_topn is not None:
      oprot.writeFieldBegin('disable_outermost_topn', TType.BOOL, 24)
      oprot.writeBool(self.disable_outermost_topn)
      oprot.writeFieldEnd()
    if self.rm_initial_mem is not None:
      oprot.writeFieldBegin('rm_initial_mem', TType.I64, 25)
      oprot.writeI64(self.rm_initial_mem)
      oprot.writeFieldEnd()
    if self.query_timeout_s is not None:
      oprot.writeFieldBegin('query_timeout_s', TType.I32, 26)
      oprot.writeI32(self.query_timeout_s)
      oprot.writeFieldEnd()
    if self.buffer_pool_limit is not None:
      oprot.writeFieldBegin('buffer_pool_limit', TType.I64, 27)
      oprot.writeI64(self.buffer_pool_limit)
      oprot.writeFieldEnd()
    if self.appx_count_distinct is not None:
      oprot.writeFieldBegin('appx_count_distinct', TType.BOOL, 28)
      oprot.writeBool(self.appx_count_distinct)
      oprot.writeFieldEnd()
    if self.disable_unsafe_spills is not None:
      oprot.writeFieldBegin('disable_unsafe_spills', TType.BOOL, 29)
      oprot.writeBool(self.disable_unsafe_spills)
      oprot.writeFieldEnd()
    if self.seq_compression_mode is not None:
      oprot.writeFieldBegin('seq_compression_mode', TType.I32, 30)
      oprot.writeI32(self.seq_compression_mode)
      oprot.writeFieldEnd()
    if self.exec_single_node_rows_threshold is not None:
      oprot.writeFieldBegin('exec_single_node_rows_threshold', TType.I32, 31)
      oprot.writeI32(self.exec_single_node_rows_threshold)
      oprot.writeFieldEnd()
    if self.optimize_partition_key_scans is not None:
      oprot.writeFieldBegin('optimize_partition_key_scans', TType.BOOL, 32)
      oprot.writeBool(self.optimize_partition_key_scans)
      oprot.writeFieldEnd()
    if self.replica_preference is not None:
      oprot.writeFieldBegin('replica_preference', TType.I32, 33)
      oprot.writeI32(self.replica_preference)
      oprot.writeFieldEnd()
    if self.schedule_random_replica is not None:
      oprot.writeFieldBegin('schedule_random_replica', TType.BOOL, 34)
      oprot.writeBool(self.schedule_random_replica)
      oprot.writeFieldEnd()
    if self.scan_node_codegen_threshold is not None:
      oprot.writeFieldBegin('scan_node_codegen_threshold', TType.I64, 35)
      oprot.writeI64(self.scan_node_codegen_threshold)
      oprot.writeFieldEnd()
    if self.disable_streaming_preaggregations is not None:
      oprot.writeFieldBegin('disable_streaming_preaggregations', TType.BOOL, 36)
      oprot.writeBool(self.disable_streaming_preaggregations)
      oprot.writeFieldEnd()
    if self.runtime_filter_mode is not None:
      oprot.writeFieldBegin('runtime_filter_mode', TType.I32, 37)
      oprot.writeI32(self.runtime_filter_mode)
      oprot.writeFieldEnd()
    if self.runtime_bloom_filter_size is not None:
      oprot.writeFieldBegin('runtime_bloom_filter_size', TType.I32, 38)
      oprot.writeI32(self.runtime_bloom_filter_size)
      oprot.writeFieldEnd()
    if self.runtime_filter_wait_time_ms is not None:
      oprot.writeFieldBegin('runtime_filter_wait_time_ms', TType.I32, 39)
      oprot.writeI32(self.runtime_filter_wait_time_ms)
      oprot.writeFieldEnd()
    if self.disable_row_runtime_filtering is not None:
      oprot.writeFieldBegin('disable_row_runtime_filtering', TType.BOOL, 40)
      oprot.writeBool(self.disable_row_runtime_filtering)
      oprot.writeFieldEnd()
    if self.max_num_runtime_filters is not None:
      oprot.writeFieldBegin('max_num_runtime_filters', TType.I32, 41)
      oprot.writeI32(self.max_num_runtime_filters)
      oprot.writeFieldEnd()
    if self.parquet_annotate_strings_utf8 is not None:
      oprot.writeFieldBegin('parquet_annotate_strings_utf8', TType.BOOL, 42)
      oprot.writeBool(self.parquet_annotate_strings_utf8)
      oprot.writeFieldEnd()
    if self.parquet_fallback_schema_resolution is not None:
      oprot.writeFieldBegin('parquet_fallback_schema_resolution', TType.I32, 43)
      oprot.writeI32(self.parquet_fallback_schema_resolution)
      oprot.writeFieldEnd()
    if self.mt_dop is not None:
      oprot.writeFieldBegin('mt_dop', TType.I32, 44)
      oprot.writeI32(self.mt_dop)
      oprot.writeFieldEnd()
    if self.s3_skip_insert_staging is not None:
      oprot.writeFieldBegin('s3_skip_insert_staging', TType.BOOL, 45)
      oprot.writeBool(self.s3_skip_insert_staging)
      oprot.writeFieldEnd()
    if self.runtime_filter_min_size is not None:
      oprot.writeFieldBegin('runtime_filter_min_size', TType.I32, 46)
      oprot.writeI32(self.runtime_filter_min_size)
      oprot.writeFieldEnd()
    if self.runtime_filter_max_size is not None:
      oprot.writeFieldBegin('runtime_filter_max_size', TType.I32, 47)
      oprot.writeI32(self.runtime_filter_max_size)
      oprot.writeFieldEnd()
    if self.prefetch_mode is not None:
      oprot.writeFieldBegin('prefetch_mode', TType.I32, 48)
      oprot.writeI32(self.prefetch_mode)
      oprot.writeFieldEnd()
    if self.strict_mode is not None:
      oprot.writeFieldBegin('strict_mode', TType.BOOL, 49)
      oprot.writeBool(self.strict_mode)
      oprot.writeFieldEnd()
    if self.scratch_limit is not None:
      oprot.writeFieldBegin('scratch_limit', TType.I64, 50)
      oprot.writeI64(self.scratch_limit)
      oprot.writeFieldEnd()
    if self.enable_expr_rewrites is not None:
      oprot.writeFieldBegin('enable_expr_rewrites', TType.BOOL, 51)
      oprot.writeBool(self.enable_expr_rewrites)
      oprot.writeFieldEnd()
    if self.decimal_v2 is not None:
      oprot.writeFieldBegin('decimal_v2', TType.BOOL, 52)
      oprot.writeBool(self.decimal_v2)
      oprot.writeFieldEnd()
    if self.parquet_dictionary_filtering is not None:
      oprot.writeFieldBegin('parquet_dictionary_filtering', TType.BOOL, 53)
      oprot.writeBool(self.parquet_dictionary_filtering)
      oprot.writeFieldEnd()
    if self.parquet_array_resolution is not None:
      oprot.writeFieldBegin('parquet_array_resolution', TType.I32, 54)
      oprot.writeI32(self.parquet_array_resolution)
      oprot.writeFieldEnd()
    if self.parquet_read_statistics is not None:
      oprot.writeFieldBegin('parquet_read_statistics', TType.BOOL, 55)
      oprot.writeBool(self.parquet_read_statistics)
      oprot.writeFieldEnd()
    if self.default_join_distribution_mode is not None:
      oprot.writeFieldBegin('default_join_distribution_mode', TType.I32, 56)
      oprot.writeI32(self.default_join_distribution_mode)
      oprot.writeFieldEnd()
    if self.disable_codegen_rows_threshold is not None:
      oprot.writeFieldBegin('disable_codegen_rows_threshold', TType.I32, 57)
      oprot.writeI32(self.disable_codegen_rows_threshold)
      oprot.writeFieldEnd()
    if self.default_spillable_buffer_size is not None:
      oprot.writeFieldBegin('default_spillable_buffer_size', TType.I64, 58)
      oprot.writeI64(self.default_spillable_buffer_size)
      oprot.writeFieldEnd()
    if self.min_spillable_buffer_size is not None:
      oprot.writeFieldBegin('min_spillable_buffer_size', TType.I64, 59)
      oprot.writeI64(self.min_spillable_buffer_size)
      oprot.writeFieldEnd()
    if self.max_row_size is not None:
      oprot.writeFieldBegin('max_row_size', TType.I64, 60)
      oprot.writeI64(self.max_row_size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSessionState:
  """
  Attributes:
   - session_id
   - session_type
   - database
   - connected_user
   - delegated_user
   - network_address
   - kudu_latest_observed_ts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'database', None, None, ), # 1
    (2, TType.STRING, 'connected_user', None, None, ), # 2
    (3, TType.STRUCT, 'session_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'network_address', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 4
    (5, TType.I32, 'session_type', None, None, ), # 5
    (6, TType.STRING, 'delegated_user', None, None, ), # 6
    (7, TType.I64, 'kudu_latest_observed_ts', None, None, ), # 7
  )

  def __init__(self, session_id=None, session_type=None, database=None, connected_user=None, delegated_user=None, network_address=None, kudu_latest_observed_ts=None,):
    self.session_id = session_id
    self.session_type = session_type
    self.database = database
    self.connected_user = connected_user
    self.delegated_user = delegated_user
    self.network_address = network_address
    self.kudu_latest_observed_ts = kudu_latest_observed_ts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 3:
        if ftype == TType.STRUCT:
          self.session_id = Types.ttypes.TUniqueId()
          self.session_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.session_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRING:
          self.database = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.connected_user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.delegated_user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.network_address = Types.ttypes.TNetworkAddress()
          self.network_address.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.kudu_latest_observed_ts = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSessionState')
    if self.database is not None:
      oprot.writeFieldBegin('database', TType.STRING, 1)
      oprot.writeString(self.database)
      oprot.writeFieldEnd()
    if self.connected_user is not None:
      oprot.writeFieldBegin('connected_user', TType.STRING, 2)
      oprot.writeString(self.connected_user)
      oprot.writeFieldEnd()
    if self.session_id is not None:
      oprot.writeFieldBegin('session_id', TType.STRUCT, 3)
      self.session_id.write(oprot)
      oprot.writeFieldEnd()
    if self.network_address is not None:
      oprot.writeFieldBegin('network_address', TType.STRUCT, 4)
      self.network_address.write(oprot)
      oprot.writeFieldEnd()
    if self.session_type is not None:
      oprot.writeFieldBegin('session_type', TType.I32, 5)
      oprot.writeI32(self.session_type)
      oprot.writeFieldEnd()
    if self.delegated_user is not None:
      oprot.writeFieldBegin('delegated_user', TType.STRING, 6)
      oprot.writeString(self.delegated_user)
      oprot.writeFieldEnd()
    if self.kudu_latest_observed_ts is not None:
      oprot.writeFieldBegin('kudu_latest_observed_ts', TType.I64, 7)
      oprot.writeI64(self.kudu_latest_observed_ts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.session_id is None:
      raise TProtocol.TProtocolException(message='Required field session_id is unset!')
    if self.session_type is None:
      raise TProtocol.TProtocolException(message='Required field session_type is unset!')
    if self.database is None:
      raise TProtocol.TProtocolException(message='Required field database is unset!')
    if self.connected_user is None:
      raise TProtocol.TProtocolException(message='Required field connected_user is unset!')
    if self.network_address is None:
      raise TProtocol.TProtocolException(message='Required field network_address is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TClientRequest:
  """
  Attributes:
   - stmt
   - query_options
   - redacted_stmt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'stmt', None, None, ), # 1
    (2, TType.STRUCT, 'query_options', (TQueryOptions, TQueryOptions.thrift_spec), None, ), # 2
    (3, TType.STRING, 'redacted_stmt', None, None, ), # 3
  )

  def __init__(self, stmt=None, query_options=None, redacted_stmt=None,):
    self.stmt = stmt
    self.query_options = query_options
    self.redacted_stmt = redacted_stmt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_options = TQueryOptions()
          self.query_options.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.redacted_stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TClientRequest')
    if self.stmt is not None:
      oprot.writeFieldBegin('stmt', TType.STRING, 1)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    if self.query_options is not None:
      oprot.writeFieldBegin('query_options', TType.STRUCT, 2)
      self.query_options.write(oprot)
      oprot.writeFieldEnd()
    if self.redacted_stmt is not None:
      oprot.writeFieldBegin('redacted_stmt', TType.STRING, 3)
      oprot.writeString(self.redacted_stmt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.stmt is None:
      raise TProtocol.TProtocolException(message='Required field stmt is unset!')
    if self.query_options is None:
      raise TProtocol.TProtocolException(message='Required field query_options is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDebugOptions:
  """
  Attributes:
   - node_id
   - phase
   - action
   - action_param
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'node_id', None, None, ), # 1
    (2, TType.I32, 'phase', None, None, ), # 2
    (3, TType.I32, 'action', None, None, ), # 3
    (4, TType.STRING, 'action_param', None, None, ), # 4
  )

  def __init__(self, node_id=None, phase=None, action=None, action_param=None,):
    self.node_id = node_id
    self.phase = phase
    self.action = action
    self.action_param = action_param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.phase = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.action_param = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDebugOptions')
    if self.node_id is not None:
      oprot.writeFieldBegin('node_id', TType.I32, 1)
      oprot.writeI32(self.node_id)
      oprot.writeFieldEnd()
    if self.phase is not None:
      oprot.writeFieldBegin('phase', TType.I32, 2)
      oprot.writeI32(self.phase)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 3)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.action_param is not None:
      oprot.writeFieldBegin('action_param', TType.STRING, 4)
      oprot.writeString(self.action_param)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TQueryCtx:
  """
  Attributes:
   - client_request
   - query_id
   - session
   - now_string
   - pid
   - coord_address
   - tables_missing_stats
   - disable_spilling
   - parent_query_id
   - tables_with_corrupt_stats
   - snapshot_timestamp
   - desc_tbl
   - start_unix_millis
   - disable_codegen_hint
   - tables_missing_diskids
   - request_pool
   - utc_timestamp_string
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'client_request', (TClientRequest, TClientRequest.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'session', (TSessionState, TSessionState.thrift_spec), None, ), # 3
    (4, TType.STRING, 'now_string', None, None, ), # 4
    (5, TType.I32, 'pid', None, None, ), # 5
    (6, TType.STRUCT, 'coord_address', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 6
    (7, TType.LIST, 'tables_missing_stats', (TType.STRUCT,(CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec)), None, ), # 7
    (8, TType.BOOL, 'disable_spilling', None, None, ), # 8
    (9, TType.STRUCT, 'parent_query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 9
    (10, TType.LIST, 'tables_with_corrupt_stats', (TType.STRUCT,(CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec)), None, ), # 10
    (11, TType.I64, 'snapshot_timestamp', None, -1, ), # 11
    (12, TType.STRUCT, 'desc_tbl', (Descriptors.ttypes.TDescriptorTable, Descriptors.ttypes.TDescriptorTable.thrift_spec), None, ), # 12
    (13, TType.I64, 'start_unix_millis', None, None, ), # 13
    (14, TType.BOOL, 'disable_codegen_hint', None, False, ), # 14
    (15, TType.LIST, 'tables_missing_diskids', (TType.STRUCT,(CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec)), None, ), # 15
    (16, TType.STRING, 'request_pool', None, None, ), # 16
    (17, TType.STRING, 'utc_timestamp_string', None, None, ), # 17
  )

  def __init__(self, client_request=None, query_id=None, session=None, now_string=None, pid=None, coord_address=None, tables_missing_stats=None, disable_spilling=None, parent_query_id=None, tables_with_corrupt_stats=None, snapshot_timestamp=thrift_spec[11][4], desc_tbl=None, start_unix_millis=None, disable_codegen_hint=thrift_spec[14][4], tables_missing_diskids=None, request_pool=None, utc_timestamp_string=None,):
    self.client_request = client_request
    self.query_id = query_id
    self.session = session
    self.now_string = now_string
    self.pid = pid
    self.coord_address = coord_address
    self.tables_missing_stats = tables_missing_stats
    self.disable_spilling = disable_spilling
    self.parent_query_id = parent_query_id
    self.tables_with_corrupt_stats = tables_with_corrupt_stats
    self.snapshot_timestamp = snapshot_timestamp
    self.desc_tbl = desc_tbl
    self.start_unix_millis = start_unix_millis
    self.disable_codegen_hint = disable_codegen_hint
    self.tables_missing_diskids = tables_missing_diskids
    self.request_pool = request_pool
    self.utc_timestamp_string = utc_timestamp_string

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.client_request = TClientRequest()
          self.client_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_id = Types.ttypes.TUniqueId()
          self.query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.now_string = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.pid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.coord_address = Types.ttypes.TNetworkAddress()
          self.coord_address.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.tables_missing_stats = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = CatalogObjects.ttypes.TTableName()
            _elem5.read(iprot)
            self.tables_missing_stats.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.disable_spilling = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.parent_query_id = Types.ttypes.TUniqueId()
          self.parent_query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.tables_with_corrupt_stats = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = CatalogObjects.ttypes.TTableName()
            _elem11.read(iprot)
            self.tables_with_corrupt_stats.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.snapshot_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.desc_tbl = Descriptors.ttypes.TDescriptorTable()
          self.desc_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.start_unix_millis = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.disable_codegen_hint = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.tables_missing_diskids = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = CatalogObjects.ttypes.TTableName()
            _elem17.read(iprot)
            self.tables_missing_diskids.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.request_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.utc_timestamp_string = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryCtx')
    if self.client_request is not None:
      oprot.writeFieldBegin('client_request', TType.STRUCT, 1)
      self.client_request.write(oprot)
      oprot.writeFieldEnd()
    if self.query_id is not None:
      oprot.writeFieldBegin('query_id', TType.STRUCT, 2)
      self.query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.now_string is not None:
      oprot.writeFieldBegin('now_string', TType.STRING, 4)
      oprot.writeString(self.now_string)
      oprot.writeFieldEnd()
    if self.pid is not None:
      oprot.writeFieldBegin('pid', TType.I32, 5)
      oprot.writeI32(self.pid)
      oprot.writeFieldEnd()
    if self.coord_address is not None:
      oprot.writeFieldBegin('coord_address', TType.STRUCT, 6)
      self.coord_address.write(oprot)
      oprot.writeFieldEnd()
    if self.tables_missing_stats is not None:
      oprot.writeFieldBegin('tables_missing_stats', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.tables_missing_stats))
      for iter18 in self.tables_missing_stats:
        iter18.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.disable_spilling is not None:
      oprot.writeFieldBegin('disable_spilling', TType.BOOL, 8)
      oprot.writeBool(self.disable_spilling)
      oprot.writeFieldEnd()
    if self.parent_query_id is not None:
      oprot.writeFieldBegin('parent_query_id', TType.STRUCT, 9)
      self.parent_query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.tables_with_corrupt_stats is not None:
      oprot.writeFieldBegin('tables_with_corrupt_stats', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.tables_with_corrupt_stats))
      for iter19 in self.tables_with_corrupt_stats:
        iter19.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.snapshot_timestamp is not None:
      oprot.writeFieldBegin('snapshot_timestamp', TType.I64, 11)
      oprot.writeI64(self.snapshot_timestamp)
      oprot.writeFieldEnd()
    if self.desc_tbl is not None:
      oprot.writeFieldBegin('desc_tbl', TType.STRUCT, 12)
      self.desc_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.start_unix_millis is not None:
      oprot.writeFieldBegin('start_unix_millis', TType.I64, 13)
      oprot.writeI64(self.start_unix_millis)
      oprot.writeFieldEnd()
    if self.disable_codegen_hint is not None:
      oprot.writeFieldBegin('disable_codegen_hint', TType.BOOL, 14)
      oprot.writeBool(self.disable_codegen_hint)
      oprot.writeFieldEnd()
    if self.tables_missing_diskids is not None:
      oprot.writeFieldBegin('tables_missing_diskids', TType.LIST, 15)
      oprot.writeListBegin(TType.STRUCT, len(self.tables_missing_diskids))
      for iter20 in self.tables_missing_diskids:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.request_pool is not None:
      oprot.writeFieldBegin('request_pool', TType.STRING, 16)
      oprot.writeString(self.request_pool)
      oprot.writeFieldEnd()
    if self.utc_timestamp_string is not None:
      oprot.writeFieldBegin('utc_timestamp_string', TType.STRING, 17)
      oprot.writeString(self.utc_timestamp_string)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.client_request is None:
      raise TProtocol.TProtocolException(message='Required field client_request is unset!')
    if self.query_id is None:
      raise TProtocol.TProtocolException(message='Required field query_id is unset!')
    if self.session is None:
      raise TProtocol.TProtocolException(message='Required field session is unset!')
    if self.now_string is None:
      raise TProtocol.TProtocolException(message='Required field now_string is unset!')
    if self.pid is None:
      raise TProtocol.TProtocolException(message='Required field pid is unset!')
    if self.start_unix_millis is None:
      raise TProtocol.TProtocolException(message='Required field start_unix_millis is unset!')
    if self.utc_timestamp_string is None:
      raise TProtocol.TProtocolException(message='Required field utc_timestamp_string is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanFragmentDestination:
  """
  Attributes:
   - fragment_instance_id
   - server
   - krpc_server
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'server', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'krpc_server', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 3
  )

  def __init__(self, fragment_instance_id=None, server=None, krpc_server=None,):
    self.fragment_instance_id = fragment_instance_id
    self.server = server
    self.krpc_server = krpc_server

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.server = Types.ttypes.TNetworkAddress()
          self.server.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.krpc_server = Types.ttypes.TNetworkAddress()
          self.krpc_server.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanFragmentDestination')
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 1)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.server is not None:
      oprot.writeFieldBegin('server', TType.STRUCT, 2)
      self.server.write(oprot)
      oprot.writeFieldEnd()
    if self.krpc_server is not None:
      oprot.writeFieldBegin('krpc_server', TType.STRUCT, 3)
      self.krpc_server.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fragment_instance_id is None:
      raise TProtocol.TProtocolException(message='Required field fragment_instance_id is unset!')
    if self.server is None:
      raise TProtocol.TProtocolException(message='Required field server is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanFragmentCtx:
  """
  Attributes:
   - fragment
   - destinations
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fragment', (Planner.ttypes.TPlanFragment, Planner.ttypes.TPlanFragment.thrift_spec), None, ), # 1
    (2, TType.LIST, 'destinations', (TType.STRUCT,(TPlanFragmentDestination, TPlanFragmentDestination.thrift_spec)), None, ), # 2
  )

  def __init__(self, fragment=None, destinations=None,):
    self.fragment = fragment
    self.destinations = destinations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fragment = Planner.ttypes.TPlanFragment()
          self.fragment.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.destinations = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = TPlanFragmentDestination()
            _elem26.read(iprot)
            self.destinations.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanFragmentCtx')
    if self.fragment is not None:
      oprot.writeFieldBegin('fragment', TType.STRUCT, 1)
      self.fragment.write(oprot)
      oprot.writeFieldEnd()
    if self.destinations is not None:
      oprot.writeFieldBegin('destinations', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.destinations))
      for iter27 in self.destinations:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fragment is None:
      raise TProtocol.TProtocolException(message='Required field fragment is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TScanRangeParams:
  """
  Attributes:
   - scan_range
   - volume_id
   - is_cached
   - is_remote
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'scan_range', (PlanNodes.ttypes.TScanRange, PlanNodes.ttypes.TScanRange.thrift_spec), None, ), # 1
    (2, TType.I32, 'volume_id', None, -1, ), # 2
    (3, TType.BOOL, 'is_cached', None, False, ), # 3
    (4, TType.BOOL, 'is_remote', None, None, ), # 4
  )

  def __init__(self, scan_range=None, volume_id=thrift_spec[2][4], is_cached=thrift_spec[3][4], is_remote=None,):
    self.scan_range = scan_range
    self.volume_id = volume_id
    self.is_cached = is_cached
    self.is_remote = is_remote

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.scan_range = PlanNodes.ttypes.TScanRange()
          self.scan_range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.volume_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_cached = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_remote = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TScanRangeParams')
    if self.scan_range is not None:
      oprot.writeFieldBegin('scan_range', TType.STRUCT, 1)
      self.scan_range.write(oprot)
      oprot.writeFieldEnd()
    if self.volume_id is not None:
      oprot.writeFieldBegin('volume_id', TType.I32, 2)
      oprot.writeI32(self.volume_id)
      oprot.writeFieldEnd()
    if self.is_cached is not None:
      oprot.writeFieldBegin('is_cached', TType.BOOL, 3)
      oprot.writeBool(self.is_cached)
      oprot.writeFieldEnd()
    if self.is_remote is not None:
      oprot.writeFieldBegin('is_remote', TType.BOOL, 4)
      oprot.writeBool(self.is_remote)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scan_range is None:
      raise TProtocol.TProtocolException(message='Required field scan_range is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanFragmentInstanceCtx:
  """
  Attributes:
   - fragment_idx
   - fragment_instance_id
   - per_fragment_instance_idx
   - per_node_scan_ranges
   - per_exch_num_senders
   - sender_id
   - debug_options
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'fragment_idx', None, None, ), # 1
    (2, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.I32, 'per_fragment_instance_idx', None, None, ), # 3
    (4, TType.MAP, 'per_node_scan_ranges', (TType.I32,None,TType.LIST,(TType.STRUCT,(TScanRangeParams, TScanRangeParams.thrift_spec))), None, ), # 4
    (5, TType.MAP, 'per_exch_num_senders', (TType.I32,None,TType.I32,None), None, ), # 5
    (6, TType.I32, 'sender_id', None, None, ), # 6
    (7, TType.STRUCT, 'debug_options', (TDebugOptions, TDebugOptions.thrift_spec), None, ), # 7
  )

  def __init__(self, fragment_idx=None, fragment_instance_id=None, per_fragment_instance_idx=None, per_node_scan_ranges=None, per_exch_num_senders=None, sender_id=None, debug_options=None,):
    self.fragment_idx = fragment_idx
    self.fragment_instance_id = fragment_instance_id
    self.per_fragment_instance_idx = per_fragment_instance_idx
    self.per_node_scan_ranges = per_node_scan_ranges
    self.per_exch_num_senders = per_exch_num_senders
    self.sender_id = sender_id
    self.debug_options = debug_options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.fragment_idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.per_fragment_instance_idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.per_node_scan_ranges = {}
          (_ktype29, _vtype30, _size28 ) = iprot.readMapBegin() 
          for _i32 in xrange(_size28):
            _key33 = iprot.readI32();
            _val34 = []
            (_etype38, _size35) = iprot.readListBegin()
            for _i39 in xrange(_size35):
              _elem40 = TScanRangeParams()
              _elem40.read(iprot)
              _val34.append(_elem40)
            iprot.readListEnd()
            self.per_node_scan_ranges[_key33] = _val34
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.per_exch_num_senders = {}
          (_ktype42, _vtype43, _size41 ) = iprot.readMapBegin() 
          for _i45 in xrange(_size41):
            _key46 = iprot.readI32();
            _val47 = iprot.readI32();
            self.per_exch_num_senders[_key46] = _val47
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.sender_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.debug_options = TDebugOptions()
          self.debug_options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanFragmentInstanceCtx')
    if self.fragment_idx is not None:
      oprot.writeFieldBegin('fragment_idx', TType.I32, 1)
      oprot.writeI32(self.fragment_idx)
      oprot.writeFieldEnd()
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 2)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.per_fragment_instance_idx is not None:
      oprot.writeFieldBegin('per_fragment_instance_idx', TType.I32, 3)
      oprot.writeI32(self.per_fragment_instance_idx)
      oprot.writeFieldEnd()
    if self.per_node_scan_ranges is not None:
      oprot.writeFieldBegin('per_node_scan_ranges', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.per_node_scan_ranges))
      for kiter48,viter49 in self.per_node_scan_ranges.items():
        oprot.writeI32(kiter48)
        oprot.writeListBegin(TType.STRUCT, len(viter49))
        for iter50 in viter49:
          iter50.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.per_exch_num_senders is not None:
      oprot.writeFieldBegin('per_exch_num_senders', TType.MAP, 5)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.per_exch_num_senders))
      for kiter51,viter52 in self.per_exch_num_senders.items():
        oprot.writeI32(kiter51)
        oprot.writeI32(viter52)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.sender_id is not None:
      oprot.writeFieldBegin('sender_id', TType.I32, 6)
      oprot.writeI32(self.sender_id)
      oprot.writeFieldEnd()
    if self.debug_options is not None:
      oprot.writeFieldBegin('debug_options', TType.STRUCT, 7)
      self.debug_options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fragment_idx is None:
      raise TProtocol.TProtocolException(message='Required field fragment_idx is unset!')
    if self.fragment_instance_id is None:
      raise TProtocol.TProtocolException(message='Required field fragment_instance_id is unset!')
    if self.per_fragment_instance_idx is None:
      raise TProtocol.TProtocolException(message='Required field per_fragment_instance_idx is unset!')
    if self.per_node_scan_ranges is None:
      raise TProtocol.TProtocolException(message='Required field per_node_scan_ranges is unset!')
    if self.per_exch_num_senders is None:
      raise TProtocol.TProtocolException(message='Required field per_exch_num_senders is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecQueryFInstancesParams:
  """
  Attributes:
   - protocol_version
   - coord_state_idx
   - query_ctx
   - fragment_ctxs
   - fragment_instance_ctxs
   - min_reservation_bytes
   - initial_reservation_total_claims
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.I32, 'coord_state_idx', None, None, ), # 2
    (3, TType.STRUCT, 'query_ctx', (TQueryCtx, TQueryCtx.thrift_spec), None, ), # 3
    (4, TType.LIST, 'fragment_ctxs', (TType.STRUCT,(TPlanFragmentCtx, TPlanFragmentCtx.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'fragment_instance_ctxs', (TType.STRUCT,(TPlanFragmentInstanceCtx, TPlanFragmentInstanceCtx.thrift_spec)), None, ), # 5
    (6, TType.I64, 'min_reservation_bytes', None, None, ), # 6
    (7, TType.I64, 'initial_reservation_total_claims', None, None, ), # 7
  )

  def __init__(self, protocol_version=None, coord_state_idx=None, query_ctx=None, fragment_ctxs=None, fragment_instance_ctxs=None, min_reservation_bytes=None, initial_reservation_total_claims=None,):
    self.protocol_version = protocol_version
    self.coord_state_idx = coord_state_idx
    self.query_ctx = query_ctx
    self.fragment_ctxs = fragment_ctxs
    self.fragment_instance_ctxs = fragment_instance_ctxs
    self.min_reservation_bytes = min_reservation_bytes
    self.initial_reservation_total_claims = initial_reservation_total_claims

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.coord_state_idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.query_ctx = TQueryCtx()
          self.query_ctx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fragment_ctxs = []
          (_etype56, _size53) = iprot.readListBegin()
          for _i57 in xrange(_size53):
            _elem58 = TPlanFragmentCtx()
            _elem58.read(iprot)
            self.fragment_ctxs.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.fragment_instance_ctxs = []
          (_etype62, _size59) = iprot.readListBegin()
          for _i63 in xrange(_size59):
            _elem64 = TPlanFragmentInstanceCtx()
            _elem64.read(iprot)
            self.fragment_instance_ctxs.append(_elem64)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.min_reservation_bytes = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.initial_reservation_total_claims = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecQueryFInstancesParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.coord_state_idx is not None:
      oprot.writeFieldBegin('coord_state_idx', TType.I32, 2)
      oprot.writeI32(self.coord_state_idx)
      oprot.writeFieldEnd()
    if self.query_ctx is not None:
      oprot.writeFieldBegin('query_ctx', TType.STRUCT, 3)
      self.query_ctx.write(oprot)
      oprot.writeFieldEnd()
    if self.fragment_ctxs is not None:
      oprot.writeFieldBegin('fragment_ctxs', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fragment_ctxs))
      for iter65 in self.fragment_ctxs:
        iter65.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fragment_instance_ctxs is not None:
      oprot.writeFieldBegin('fragment_instance_ctxs', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.fragment_instance_ctxs))
      for iter66 in self.fragment_instance_ctxs:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.min_reservation_bytes is not None:
      oprot.writeFieldBegin('min_reservation_bytes', TType.I64, 6)
      oprot.writeI64(self.min_reservation_bytes)
      oprot.writeFieldEnd()
    if self.initial_reservation_total_claims is not None:
      oprot.writeFieldBegin('initial_reservation_total_claims', TType.I64, 7)
      oprot.writeI64(self.initial_reservation_total_claims)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecQueryFInstancesResult:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecQueryFInstancesResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TParquetInsertStats:
  """
  Attributes:
   - per_column_size
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'per_column_size', (TType.STRING,None,TType.I64,None), None, ), # 1
  )

  def __init__(self, per_column_size=None,):
    self.per_column_size = per_column_size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.per_column_size = {}
          (_ktype68, _vtype69, _size67 ) = iprot.readMapBegin() 
          for _i71 in xrange(_size67):
            _key72 = iprot.readString();
            _val73 = iprot.readI64();
            self.per_column_size[_key72] = _val73
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TParquetInsertStats')
    if self.per_column_size is not None:
      oprot.writeFieldBegin('per_column_size', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.per_column_size))
      for kiter74,viter75 in self.per_column_size.items():
        oprot.writeString(kiter74)
        oprot.writeI64(viter75)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.per_column_size is None:
      raise TProtocol.TProtocolException(message='Required field per_column_size is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TKuduDmlStats:
  """
  Attributes:
   - num_row_errors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'num_row_errors', None, None, ), # 1
  )

  def __init__(self, num_row_errors=None,):
    self.num_row_errors = num_row_errors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.num_row_errors = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TKuduDmlStats')
    if self.num_row_errors is not None:
      oprot.writeFieldBegin('num_row_errors', TType.I64, 1)
      oprot.writeI64(self.num_row_errors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TInsertStats:
  """
  Attributes:
   - bytes_written
   - parquet_stats
   - kudu_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'bytes_written', None, None, ), # 1
    (2, TType.STRUCT, 'parquet_stats', (TParquetInsertStats, TParquetInsertStats.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'kudu_stats', (TKuduDmlStats, TKuduDmlStats.thrift_spec), None, ), # 3
  )

  def __init__(self, bytes_written=None, parquet_stats=None, kudu_stats=None,):
    self.bytes_written = bytes_written
    self.parquet_stats = parquet_stats
    self.kudu_stats = kudu_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.bytes_written = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.parquet_stats = TParquetInsertStats()
          self.parquet_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.kudu_stats = TKuduDmlStats()
          self.kudu_stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TInsertStats')
    if self.bytes_written is not None:
      oprot.writeFieldBegin('bytes_written', TType.I64, 1)
      oprot.writeI64(self.bytes_written)
      oprot.writeFieldEnd()
    if self.parquet_stats is not None:
      oprot.writeFieldBegin('parquet_stats', TType.STRUCT, 2)
      self.parquet_stats.write(oprot)
      oprot.writeFieldEnd()
    if self.kudu_stats is not None:
      oprot.writeFieldBegin('kudu_stats', TType.STRUCT, 3)
      self.kudu_stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.bytes_written is None:
      raise TProtocol.TProtocolException(message='Required field bytes_written is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TInsertPartitionStatus:
  """
  Attributes:
   - id
   - num_modified_rows
   - stats
   - partition_base_dir
   - kudu_latest_observed_ts
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I64, 'num_modified_rows', None, None, ), # 2
    (3, TType.STRUCT, 'stats', (TInsertStats, TInsertStats.thrift_spec), None, ), # 3
    (4, TType.STRING, 'partition_base_dir', None, None, ), # 4
    (5, TType.I64, 'kudu_latest_observed_ts', None, None, ), # 5
  )

  def __init__(self, id=None, num_modified_rows=None, stats=None, partition_base_dir=None, kudu_latest_observed_ts=None,):
    self.id = id
    self.num_modified_rows = num_modified_rows
    self.stats = stats
    self.partition_base_dir = partition_base_dir
    self.kudu_latest_observed_ts = kudu_latest_observed_ts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.num_modified_rows = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.stats = TInsertStats()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partition_base_dir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.kudu_latest_observed_ts = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TInsertPartitionStatus')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.num_modified_rows is not None:
      oprot.writeFieldBegin('num_modified_rows', TType.I64, 2)
      oprot.writeI64(self.num_modified_rows)
      oprot.writeFieldEnd()
    if self.stats is not None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 3)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_base_dir is not None:
      oprot.writeFieldBegin('partition_base_dir', TType.STRING, 4)
      oprot.writeString(self.partition_base_dir)
      oprot.writeFieldEnd()
    if self.kudu_latest_observed_ts is not None:
      oprot.writeFieldBegin('kudu_latest_observed_ts', TType.I64, 5)
      oprot.writeI64(self.kudu_latest_observed_ts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partition_base_dir is None:
      raise TProtocol.TProtocolException(message='Required field partition_base_dir is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TInsertExecStatus:
  """
  Attributes:
   - files_to_move
   - per_partition_status
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'files_to_move', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.MAP, 'per_partition_status', (TType.STRING,None,TType.STRUCT,(TInsertPartitionStatus, TInsertPartitionStatus.thrift_spec)), None, ), # 2
  )

  def __init__(self, files_to_move=None, per_partition_status=None,):
    self.files_to_move = files_to_move
    self.per_partition_status = per_partition_status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.files_to_move = {}
          (_ktype77, _vtype78, _size76 ) = iprot.readMapBegin() 
          for _i80 in xrange(_size76):
            _key81 = iprot.readString();
            _val82 = iprot.readString();
            self.files_to_move[_key81] = _val82
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.per_partition_status = {}
          (_ktype84, _vtype85, _size83 ) = iprot.readMapBegin() 
          for _i87 in xrange(_size83):
            _key88 = iprot.readString();
            _val89 = TInsertPartitionStatus()
            _val89.read(iprot)
            self.per_partition_status[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TInsertExecStatus')
    if self.files_to_move is not None:
      oprot.writeFieldBegin('files_to_move', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.files_to_move))
      for kiter90,viter91 in self.files_to_move.items():
        oprot.writeString(kiter90)
        oprot.writeString(viter91)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.per_partition_status is not None:
      oprot.writeFieldBegin('per_partition_status', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.per_partition_status))
      for kiter92,viter93 in self.per_partition_status.items():
        oprot.writeString(kiter92)
        viter93.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.files_to_move is None:
      raise TProtocol.TProtocolException(message='Required field files_to_move is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TErrorLogEntry:
  """
  Attributes:
   - count
   - messages
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'count', None, 0, ), # 1
    (2, TType.LIST, 'messages', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, count=thrift_spec[1][4], messages=None,):
    self.count = count
    self.messages = messages

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.messages = []
          (_etype97, _size94) = iprot.readListBegin()
          for _i98 in xrange(_size94):
            _elem99 = iprot.readString();
            self.messages.append(_elem99)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TErrorLogEntry')
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 1)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    if self.messages is not None:
      oprot.writeFieldBegin('messages', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.messages))
      for iter100 in self.messages:
        oprot.writeString(iter100)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFragmentInstanceExecStatus:
  """
  Attributes:
   - fragment_instance_id
   - status
   - done
   - profile
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'done', None, None, ), # 3
    (4, TType.STRUCT, 'profile', (RuntimeProfile.ttypes.TRuntimeProfileTree, RuntimeProfile.ttypes.TRuntimeProfileTree.thrift_spec), None, ), # 4
  )

  def __init__(self, fragment_instance_id=None, status=None, done=None, profile=None,):
    self.fragment_instance_id = fragment_instance_id
    self.status = status
    self.done = done
    self.profile = profile

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.done = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.profile = RuntimeProfile.ttypes.TRuntimeProfileTree()
          self.profile.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFragmentInstanceExecStatus')
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 1)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 2)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.done is not None:
      oprot.writeFieldBegin('done', TType.BOOL, 3)
      oprot.writeBool(self.done)
      oprot.writeFieldEnd()
    if self.profile is not None:
      oprot.writeFieldBegin('profile', TType.STRUCT, 4)
      self.profile.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TReportExecStatusParams:
  """
  Attributes:
   - protocol_version
   - query_id
   - coord_state_idx
   - instance_exec_status
   - insert_exec_status
   - error_log
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.I32, 'coord_state_idx', None, None, ), # 3
    (4, TType.LIST, 'instance_exec_status', (TType.STRUCT,(TFragmentInstanceExecStatus, TFragmentInstanceExecStatus.thrift_spec)), None, ), # 4
    (5, TType.STRUCT, 'insert_exec_status', (TInsertExecStatus, TInsertExecStatus.thrift_spec), None, ), # 5
    (6, TType.MAP, 'error_log', (TType.I32,None,TType.STRUCT,(TErrorLogEntry, TErrorLogEntry.thrift_spec)), None, ), # 6
    (7, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 7
  )

  def __init__(self, protocol_version=None, query_id=None, coord_state_idx=None, instance_exec_status=None, insert_exec_status=None, error_log=None, status=None,):
    self.protocol_version = protocol_version
    self.query_id = query_id
    self.coord_state_idx = coord_state_idx
    self.instance_exec_status = instance_exec_status
    self.insert_exec_status = insert_exec_status
    self.error_log = error_log
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_id = Types.ttypes.TUniqueId()
          self.query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.coord_state_idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.instance_exec_status = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = TFragmentInstanceExecStatus()
            _elem106.read(iprot)
            self.instance_exec_status.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.insert_exec_status = TInsertExecStatus()
          self.insert_exec_status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.error_log = {}
          (_ktype108, _vtype109, _size107 ) = iprot.readMapBegin() 
          for _i111 in xrange(_size107):
            _key112 = iprot.readI32();
            _val113 = TErrorLogEntry()
            _val113.read(iprot)
            self.error_log[_key112] = _val113
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TReportExecStatusParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.query_id is not None:
      oprot.writeFieldBegin('query_id', TType.STRUCT, 2)
      self.query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.coord_state_idx is not None:
      oprot.writeFieldBegin('coord_state_idx', TType.I32, 3)
      oprot.writeI32(self.coord_state_idx)
      oprot.writeFieldEnd()
    if self.instance_exec_status is not None:
      oprot.writeFieldBegin('instance_exec_status', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.instance_exec_status))
      for iter114 in self.instance_exec_status:
        iter114.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insert_exec_status is not None:
      oprot.writeFieldBegin('insert_exec_status', TType.STRUCT, 5)
      self.insert_exec_status.write(oprot)
      oprot.writeFieldEnd()
    if self.error_log is not None:
      oprot.writeFieldBegin('error_log', TType.MAP, 6)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.error_log))
      for kiter115,viter116 in self.error_log.items():
        oprot.writeI32(kiter115)
        viter116.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 7)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TReportExecStatusResult:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TReportExecStatusResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCancelQueryFInstancesParams:
  """
  Attributes:
   - protocol_version
   - query_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, protocol_version=None, query_id=None,):
    self.protocol_version = protocol_version
    self.query_id = query_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_id = Types.ttypes.TUniqueId()
          self.query_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCancelQueryFInstancesParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.query_id is not None:
      oprot.writeFieldBegin('query_id', TType.STRUCT, 2)
      self.query_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCancelQueryFInstancesResult:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCancelQueryFInstancesResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTransmitDataParams:
  """
  Attributes:
   - protocol_version
   - dest_fragment_instance_id
   - sender_id
   - dest_node_id
   - row_batch
   - eos
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'dest_fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.I32, 'sender_id', None, None, ), # 3
    (4, TType.I32, 'dest_node_id', None, None, ), # 4
    (5, TType.STRUCT, 'row_batch', (Results.ttypes.TRowBatch, Results.ttypes.TRowBatch.thrift_spec), None, ), # 5
    (6, TType.BOOL, 'eos', None, None, ), # 6
  )

  def __init__(self, protocol_version=None, dest_fragment_instance_id=None, sender_id=None, dest_node_id=None, row_batch=None, eos=None,):
    self.protocol_version = protocol_version
    self.dest_fragment_instance_id = dest_fragment_instance_id
    self.sender_id = sender_id
    self.dest_node_id = dest_node_id
    self.row_batch = row_batch
    self.eos = eos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dest_fragment_instance_id = Types.ttypes.TUniqueId()
          self.dest_fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.sender_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.dest_node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.row_batch = Results.ttypes.TRowBatch()
          self.row_batch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.eos = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTransmitDataParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.dest_fragment_instance_id is not None:
      oprot.writeFieldBegin('dest_fragment_instance_id', TType.STRUCT, 2)
      self.dest_fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.sender_id is not None:
      oprot.writeFieldBegin('sender_id', TType.I32, 3)
      oprot.writeI32(self.sender_id)
      oprot.writeFieldEnd()
    if self.dest_node_id is not None:
      oprot.writeFieldBegin('dest_node_id', TType.I32, 4)
      oprot.writeI32(self.dest_node_id)
      oprot.writeFieldEnd()
    if self.row_batch is not None:
      oprot.writeFieldBegin('row_batch', TType.STRUCT, 5)
      self.row_batch.write(oprot)
      oprot.writeFieldEnd()
    if self.eos is not None:
      oprot.writeFieldBegin('eos', TType.BOOL, 6)
      oprot.writeBool(self.eos)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTransmitDataResult:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTransmitDataResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResolveRequestPoolParams:
  """
  Attributes:
   - user
   - requested_pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
    (2, TType.STRING, 'requested_pool', None, None, ), # 2
  )

  def __init__(self, user=None, requested_pool=None,):
    self.user = user
    self.requested_pool = requested_pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.requested_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResolveRequestPoolParams')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.requested_pool is not None:
      oprot.writeFieldBegin('requested_pool', TType.STRING, 2)
      oprot.writeString(self.requested_pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.requested_pool is None:
      raise TProtocol.TProtocolException(message='Required field requested_pool is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResolveRequestPoolResult:
  """
  Attributes:
   - resolved_pool
   - has_access
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resolved_pool', None, None, ), # 1
    (2, TType.BOOL, 'has_access', None, None, ), # 2
    (3, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 3
  )

  def __init__(self, resolved_pool=None, has_access=None, status=None,):
    self.resolved_pool = resolved_pool
    self.has_access = has_access
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resolved_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_access = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResolveRequestPoolResult')
    if self.resolved_pool is not None:
      oprot.writeFieldBegin('resolved_pool', TType.STRING, 1)
      oprot.writeString(self.resolved_pool)
      oprot.writeFieldEnd()
    if self.has_access is not None:
      oprot.writeFieldBegin('has_access', TType.BOOL, 2)
      oprot.writeBool(self.has_access)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 3)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPoolConfigParams:
  """
  Attributes:
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool', None, None, ), # 1
  )

  def __init__(self, pool=None,):
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPoolConfigParams')
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.STRING, 1)
      oprot.writeString(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pool is None:
      raise TProtocol.TProtocolException(message='Required field pool is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPoolConfig:
  """
  Attributes:
   - max_requests
   - max_queued
   - max_mem_resources
   - queue_timeout_ms
   - default_query_options
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'max_requests', None, None, ), # 1
    (2, TType.I64, 'max_queued', None, None, ), # 2
    (3, TType.I64, 'max_mem_resources', None, None, ), # 3
    (4, TType.I64, 'queue_timeout_ms', None, None, ), # 4
    (5, TType.STRING, 'default_query_options', None, None, ), # 5
  )

  def __init__(self, max_requests=None, max_queued=None, max_mem_resources=None, queue_timeout_ms=None, default_query_options=None,):
    self.max_requests = max_requests
    self.max_queued = max_queued
    self.max_mem_resources = max_mem_resources
    self.queue_timeout_ms = queue_timeout_ms
    self.default_query_options = default_query_options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.max_requests = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.max_queued = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.max_mem_resources = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.queue_timeout_ms = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.default_query_options = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPoolConfig')
    if self.max_requests is not None:
      oprot.writeFieldBegin('max_requests', TType.I64, 1)
      oprot.writeI64(self.max_requests)
      oprot.writeFieldEnd()
    if self.max_queued is not None:
      oprot.writeFieldBegin('max_queued', TType.I64, 2)
      oprot.writeI64(self.max_queued)
      oprot.writeFieldEnd()
    if self.max_mem_resources is not None:
      oprot.writeFieldBegin('max_mem_resources', TType.I64, 3)
      oprot.writeI64(self.max_mem_resources)
      oprot.writeFieldEnd()
    if self.queue_timeout_ms is not None:
      oprot.writeFieldBegin('queue_timeout_ms', TType.I64, 4)
      oprot.writeI64(self.queue_timeout_ms)
      oprot.writeFieldEnd()
    if self.default_query_options is not None:
      oprot.writeFieldBegin('default_query_options', TType.STRING, 5)
      oprot.writeString(self.default_query_options)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.max_requests is None:
      raise TProtocol.TProtocolException(message='Required field max_requests is unset!')
    if self.max_queued is None:
      raise TProtocol.TProtocolException(message='Required field max_queued is unset!')
    if self.max_mem_resources is None:
      raise TProtocol.TProtocolException(message='Required field max_mem_resources is unset!')
    if self.default_query_options is None:
      raise TProtocol.TProtocolException(message='Required field default_query_options is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TBloomFilter:
  """
  Attributes:
   - log_heap_space
   - directory
   - always_true
   - always_false
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'log_heap_space', None, None, ), # 1
    (2, TType.STRING, 'directory', None, None, ), # 2
    (3, TType.BOOL, 'always_true', None, None, ), # 3
    (4, TType.BOOL, 'always_false', None, None, ), # 4
  )

  def __init__(self, log_heap_space=None, directory=None, always_true=None, always_false=None,):
    self.log_heap_space = log_heap_space
    self.directory = directory
    self.always_true = always_true
    self.always_false = always_false

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.log_heap_space = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.directory = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.always_true = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.always_false = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TBloomFilter')
    if self.log_heap_space is not None:
      oprot.writeFieldBegin('log_heap_space', TType.I32, 1)
      oprot.writeI32(self.log_heap_space)
      oprot.writeFieldEnd()
    if self.directory is not None:
      oprot.writeFieldBegin('directory', TType.STRING, 2)
      oprot.writeString(self.directory)
      oprot.writeFieldEnd()
    if self.always_true is not None:
      oprot.writeFieldBegin('always_true', TType.BOOL, 3)
      oprot.writeBool(self.always_true)
      oprot.writeFieldEnd()
    if self.always_false is not None:
      oprot.writeFieldBegin('always_false', TType.BOOL, 4)
      oprot.writeBool(self.always_false)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.log_heap_space is None:
      raise TProtocol.TProtocolException(message='Required field log_heap_space is unset!')
    if self.always_true is None:
      raise TProtocol.TProtocolException(message='Required field always_true is unset!')
    if self.always_false is None:
      raise TProtocol.TProtocolException(message='Required field always_false is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TMinMaxFilter:
  """
  Attributes:
   - always_true
   - always_false
   - min
   - max
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'always_true', None, None, ), # 1
    (2, TType.BOOL, 'always_false', None, None, ), # 2
    (3, TType.STRUCT, 'min', (Data.ttypes.TColumnValue, Data.ttypes.TColumnValue.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'max', (Data.ttypes.TColumnValue, Data.ttypes.TColumnValue.thrift_spec), None, ), # 4
  )

  def __init__(self, always_true=None, always_false=None, min=None, max=None,):
    self.always_true = always_true
    self.always_false = always_false
    self.min = min
    self.max = max

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.always_true = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.always_false = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.min = Data.ttypes.TColumnValue()
          self.min.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.max = Data.ttypes.TColumnValue()
          self.max.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TMinMaxFilter')
    if self.always_true is not None:
      oprot.writeFieldBegin('always_true', TType.BOOL, 1)
      oprot.writeBool(self.always_true)
      oprot.writeFieldEnd()
    if self.always_false is not None:
      oprot.writeFieldBegin('always_false', TType.BOOL, 2)
      oprot.writeBool(self.always_false)
      oprot.writeFieldEnd()
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.STRUCT, 3)
      self.min.write(oprot)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.STRUCT, 4)
      self.max.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.always_true is None:
      raise TProtocol.TProtocolException(message='Required field always_true is unset!')
    if self.always_false is None:
      raise TProtocol.TProtocolException(message='Required field always_false is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateFilterParams:
  """
  Attributes:
   - protocol_version
   - filter_id
   - query_id
   - bloom_filter
   - min_max_filter
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.I32, 'filter_id', None, None, ), # 2
    (3, TType.STRUCT, 'query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'bloom_filter', (TBloomFilter, TBloomFilter.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'min_max_filter', (TMinMaxFilter, TMinMaxFilter.thrift_spec), None, ), # 5
  )

  def __init__(self, protocol_version=None, filter_id=None, query_id=None, bloom_filter=None, min_max_filter=None,):
    self.protocol_version = protocol_version
    self.filter_id = filter_id
    self.query_id = query_id
    self.bloom_filter = bloom_filter
    self.min_max_filter = min_max_filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.filter_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.query_id = Types.ttypes.TUniqueId()
          self.query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.bloom_filter = TBloomFilter()
          self.bloom_filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.min_max_filter = TMinMaxFilter()
          self.min_max_filter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateFilterParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.filter_id is not None:
      oprot.writeFieldBegin('filter_id', TType.I32, 2)
      oprot.writeI32(self.filter_id)
      oprot.writeFieldEnd()
    if self.query_id is not None:
      oprot.writeFieldBegin('query_id', TType.STRUCT, 3)
      self.query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.bloom_filter is not None:
      oprot.writeFieldBegin('bloom_filter', TType.STRUCT, 4)
      self.bloom_filter.write(oprot)
      oprot.writeFieldEnd()
    if self.min_max_filter is not None:
      oprot.writeFieldBegin('min_max_filter', TType.STRUCT, 5)
      self.min_max_filter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateFilterResult:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateFilterResult')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPublishFilterParams:
  """
  Attributes:
   - protocol_version
   - filter_id
   - dst_query_id
   - dst_fragment_idx
   - bloom_filter
   - min_max_filter
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.I32, 'filter_id', None, None, ), # 2
    (3, TType.STRUCT, 'dst_query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 3
    (4, TType.I32, 'dst_fragment_idx', None, None, ), # 4
    (5, TType.STRUCT, 'bloom_filter', (TBloomFilter, TBloomFilter.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'min_max_filter', (TMinMaxFilter, TMinMaxFilter.thrift_spec), None, ), # 6
  )

  def __init__(self, protocol_version=None, filter_id=None, dst_query_id=None, dst_fragment_idx=None, bloom_filter=None, min_max_filter=None,):
    self.protocol_version = protocol_version
    self.filter_id = filter_id
    self.dst_query_id = dst_query_id
    self.dst_fragment_idx = dst_fragment_idx
    self.bloom_filter = bloom_filter
    self.min_max_filter = min_max_filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.filter_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.dst_query_id = Types.ttypes.TUniqueId()
          self.dst_query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.dst_fragment_idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.bloom_filter = TBloomFilter()
          self.bloom_filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.min_max_filter = TMinMaxFilter()
          self.min_max_filter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPublishFilterParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.filter_id is not None:
      oprot.writeFieldBegin('filter_id', TType.I32, 2)
      oprot.writeI32(self.filter_id)
      oprot.writeFieldEnd()
    if self.dst_query_id is not None:
      oprot.writeFieldBegin('dst_query_id', TType.STRUCT, 3)
      self.dst_query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.dst_fragment_idx is not None:
      oprot.writeFieldBegin('dst_fragment_idx', TType.I32, 4)
      oprot.writeI32(self.dst_fragment_idx)
      oprot.writeFieldEnd()
    if self.bloom_filter is not None:
      oprot.writeFieldBegin('bloom_filter', TType.STRUCT, 5)
      self.bloom_filter.write(oprot)
      oprot.writeFieldEnd()
    if self.min_max_filter is not None:
      oprot.writeFieldBegin('min_max_filter', TType.STRUCT, 6)
      self.min_max_filter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPublishFilterResult:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPublishFilterResult')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
