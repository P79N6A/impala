#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import CatalogObjects.ttypes
import Types.ttypes
import Status.ttypes
import TCLIService.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TDdlType:
  ALTER_TABLE = 0
  ALTER_VIEW = 1
  CREATE_DATABASE = 2
  CREATE_TABLE = 3
  CREATE_TABLE_AS_SELECT = 4
  CREATE_TABLE_LIKE = 5
  CREATE_VIEW = 6
  CREATE_FUNCTION = 7
  COMPUTE_STATS = 8
  DROP_DATABASE = 9
  DROP_TABLE = 10
  DROP_VIEW = 11
  DROP_FUNCTION = 12
  CREATE_DATA_SOURCE = 13
  DROP_DATA_SOURCE = 14
  DROP_STATS = 15
  CREATE_ROLE = 16
  DROP_ROLE = 17
  GRANT_ROLE = 18
  REVOKE_ROLE = 19
  GRANT_PRIVILEGE = 20
  REVOKE_PRIVILEGE = 21
  TRUNCATE_TABLE = 22

  _VALUES_TO_NAMES = {
    0: "ALTER_TABLE",
    1: "ALTER_VIEW",
    2: "CREATE_DATABASE",
    3: "CREATE_TABLE",
    4: "CREATE_TABLE_AS_SELECT",
    5: "CREATE_TABLE_LIKE",
    6: "CREATE_VIEW",
    7: "CREATE_FUNCTION",
    8: "COMPUTE_STATS",
    9: "DROP_DATABASE",
    10: "DROP_TABLE",
    11: "DROP_VIEW",
    12: "DROP_FUNCTION",
    13: "CREATE_DATA_SOURCE",
    14: "DROP_DATA_SOURCE",
    15: "DROP_STATS",
    16: "CREATE_ROLE",
    17: "DROP_ROLE",
    18: "GRANT_ROLE",
    19: "REVOKE_ROLE",
    20: "GRANT_PRIVILEGE",
    21: "REVOKE_PRIVILEGE",
    22: "TRUNCATE_TABLE",
  }

  _NAMES_TO_VALUES = {
    "ALTER_TABLE": 0,
    "ALTER_VIEW": 1,
    "CREATE_DATABASE": 2,
    "CREATE_TABLE": 3,
    "CREATE_TABLE_AS_SELECT": 4,
    "CREATE_TABLE_LIKE": 5,
    "CREATE_VIEW": 6,
    "CREATE_FUNCTION": 7,
    "COMPUTE_STATS": 8,
    "DROP_DATABASE": 9,
    "DROP_TABLE": 10,
    "DROP_VIEW": 11,
    "DROP_FUNCTION": 12,
    "CREATE_DATA_SOURCE": 13,
    "DROP_DATA_SOURCE": 14,
    "DROP_STATS": 15,
    "CREATE_ROLE": 16,
    "DROP_ROLE": 17,
    "GRANT_ROLE": 18,
    "REVOKE_ROLE": 19,
    "GRANT_PRIVILEGE": 20,
    "REVOKE_PRIVILEGE": 21,
    "TRUNCATE_TABLE": 22,
  }

class TAlterTableType:
  ADD_REPLACE_COLUMNS = 0
  ADD_PARTITION = 1
  ADD_DROP_RANGE_PARTITION = 2
  ALTER_COLUMN = 3
  DROP_COLUMN = 4
  DROP_PARTITION = 5
  RENAME_TABLE = 6
  RENAME_VIEW = 7
  SET_FILE_FORMAT = 8
  SET_LOCATION = 9
  SET_TBL_PROPERTIES = 10
  UPDATE_STATS = 11
  SET_CACHED = 12
  RECOVER_PARTITIONS = 13

  _VALUES_TO_NAMES = {
    0: "ADD_REPLACE_COLUMNS",
    1: "ADD_PARTITION",
    2: "ADD_DROP_RANGE_PARTITION",
    3: "ALTER_COLUMN",
    4: "DROP_COLUMN",
    5: "DROP_PARTITION",
    6: "RENAME_TABLE",
    7: "RENAME_VIEW",
    8: "SET_FILE_FORMAT",
    9: "SET_LOCATION",
    10: "SET_TBL_PROPERTIES",
    11: "UPDATE_STATS",
    12: "SET_CACHED",
    13: "RECOVER_PARTITIONS",
  }

  _NAMES_TO_VALUES = {
    "ADD_REPLACE_COLUMNS": 0,
    "ADD_PARTITION": 1,
    "ADD_DROP_RANGE_PARTITION": 2,
    "ALTER_COLUMN": 3,
    "DROP_COLUMN": 4,
    "DROP_PARTITION": 5,
    "RENAME_TABLE": 6,
    "RENAME_VIEW": 7,
    "SET_FILE_FORMAT": 8,
    "SET_LOCATION": 9,
    "SET_TBL_PROPERTIES": 10,
    "UPDATE_STATS": 11,
    "SET_CACHED": 12,
    "RECOVER_PARTITIONS": 13,
  }

class TRangePartitionOperationType:
  ADD = 0
  DROP = 1

  _VALUES_TO_NAMES = {
    0: "ADD",
    1: "DROP",
  }

  _NAMES_TO_VALUES = {
    "ADD": 0,
    "DROP": 1,
  }


class TCreateDbParams:
  """
  Attributes:
   - db
   - comment
   - location
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'comment', None, None, ), # 2
    (3, TType.STRING, 'location', None, None, ), # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ), # 4
  )

  def __init__(self, db=None, comment=None, location=None, if_not_exists=None,):
    self.db = db
    self.comment = comment
    self.location = location
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 2)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 3)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateDataSourceParams:
  """
  Attributes:
   - data_source
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'data_source', (CatalogObjects.ttypes.TDataSource, CatalogObjects.ttypes.TDataSource.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ), # 2
  )

  def __init__(self, data_source=None, if_not_exists=None,):
    self.data_source = data_source
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data_source = CatalogObjects.ttypes.TDataSource()
          self.data_source.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateDataSourceParams')
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRUCT, 1)
      self.data_source.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_source is None:
      raise TProtocol.TProtocolException(message='Required field data_source is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropDataSourceParams:
  """
  Attributes:
   - data_source
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'data_source', None, None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, data_source=None, if_exists=None,):
    self.data_source = data_source
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data_source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropDataSourceParams')
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRING, 1)
      oprot.writeString(self.data_source)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_source is None:
      raise TProtocol.TProtocolException(message='Required field data_source is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropStatsParams:
  """
  Attributes:
   - table_name
   - partition_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'partition_set', (TType.LIST,(TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec))), None, ), # 2
  )

  def __init__(self, table_name=None, partition_set=None,):
    self.table_name = table_name
    self.partition_set = partition_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_set = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = []
            (_etype9, _size6) = iprot.readListBegin()
            for _i10 in xrange(_size6):
              _elem11 = CatalogObjects.ttypes.TPartitionKeyValue()
              _elem11.read(iprot)
              _elem5.append(_elem11)
            iprot.readListEnd()
            self.partition_set.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropStatsParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_set is not None:
      oprot.writeFieldBegin('partition_set', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.partition_set))
      for iter12 in self.partition_set:
        oprot.writeListBegin(TType.STRUCT, len(iter12))
        for iter13 in iter12:
          iter13.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateFunctionParams:
  """
  Attributes:
   - fn
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fn', (Types.ttypes.TFunction, Types.ttypes.TFunction.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ), # 2
  )

  def __init__(self, fn=None, if_not_exists=None,):
    self.fn = fn
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fn = Types.ttypes.TFunction()
          self.fn.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateFunctionParams')
    if self.fn is not None:
      oprot.writeFieldBegin('fn', TType.STRUCT, 1)
      self.fn.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fn is None:
      raise TProtocol.TProtocolException(message='Required field fn is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableRowFormat:
  """
  Attributes:
   - field_terminator
   - line_terminator
   - escaped_by
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field_terminator', None, None, ), # 1
    (2, TType.STRING, 'line_terminator', None, None, ), # 2
    (3, TType.STRING, 'escaped_by', None, None, ), # 3
  )

  def __init__(self, field_terminator=None, line_terminator=None, escaped_by=None,):
    self.field_terminator = field_terminator
    self.line_terminator = line_terminator
    self.escaped_by = escaped_by

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field_terminator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.line_terminator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.escaped_by = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableRowFormat')
    if self.field_terminator is not None:
      oprot.writeFieldBegin('field_terminator', TType.STRING, 1)
      oprot.writeString(self.field_terminator)
      oprot.writeFieldEnd()
    if self.line_terminator is not None:
      oprot.writeFieldBegin('line_terminator', TType.STRING, 2)
      oprot.writeString(self.line_terminator)
      oprot.writeFieldEnd()
    if self.escaped_by is not None:
      oprot.writeFieldBegin('escaped_by', TType.STRING, 3)
      oprot.writeString(self.escaped_by)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsCachingOp:
  """
  Attributes:
   - set_cached
   - cache_pool_name
   - replication
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'set_cached', None, None, ), # 1
    (2, TType.STRING, 'cache_pool_name', None, None, ), # 2
    (3, TType.I16, 'replication', None, None, ), # 3
  )

  def __init__(self, set_cached=None, cache_pool_name=None, replication=None,):
    self.set_cached = set_cached
    self.cache_pool_name = cache_pool_name
    self.replication = replication

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.set_cached = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.cache_pool_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.replication = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsCachingOp')
    if self.set_cached is not None:
      oprot.writeFieldBegin('set_cached', TType.BOOL, 1)
      oprot.writeBool(self.set_cached)
      oprot.writeFieldEnd()
    if self.cache_pool_name is not None:
      oprot.writeFieldBegin('cache_pool_name', TType.STRING, 2)
      oprot.writeString(self.cache_pool_name)
      oprot.writeFieldEnd()
    if self.replication is not None:
      oprot.writeFieldBegin('replication', TType.I16, 3)
      oprot.writeI16(self.replication)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.set_cached is None:
      raise TProtocol.TProtocolException(message='Required field set_cached is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableOrViewRenameParams:
  """
  Attributes:
   - new_table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
  )

  def __init__(self, new_table_name=None,):
    self.new_table_name = new_table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_table_name = CatalogObjects.ttypes.TTableName()
          self.new_table_name.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableOrViewRenameParams')
    if self.new_table_name is not None:
      oprot.writeFieldBegin('new_table_name', TType.STRUCT, 1)
      self.new_table_name.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.new_table_name is None:
      raise TProtocol.TProtocolException(message='Required field new_table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableAddReplaceColsParams:
  """
  Attributes:
   - columns
   - replace_existing_cols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'columns', (TType.STRUCT,(CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'replace_existing_cols', None, None, ), # 2
  )

  def __init__(self, columns=None, replace_existing_cols=None,):
    self.columns = columns
    self.replace_existing_cols = replace_existing_cols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = CatalogObjects.ttypes.TColumn()
            _elem19.read(iprot)
            self.columns.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.replace_existing_cols = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableAddReplaceColsParams')
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter20 in self.columns:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.replace_existing_cols is not None:
      oprot.writeFieldBegin('replace_existing_cols', TType.BOOL, 2)
      oprot.writeBool(self.replace_existing_cols)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.replace_existing_cols is None:
      raise TProtocol.TProtocolException(message='Required field replace_existing_cols is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPartitionDef:
  """
  Attributes:
   - partition_spec
   - location
   - cache_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.STRUCT, 'cache_op', (THdfsCachingOp, THdfsCachingOp.thrift_spec), None, ), # 3
  )

  def __init__(self, partition_spec=None, location=None, cache_op=None,):
    self.partition_spec = partition_spec
    self.location = location
    self.cache_op = cache_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem26.read(iprot)
            self.partition_spec.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.cache_op = THdfsCachingOp()
          self.cache_op.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartitionDef')
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter27 in self.partition_spec:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.cache_op is not None:
      oprot.writeFieldBegin('cache_op', TType.STRUCT, 3)
      self.cache_op.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partition_spec is None:
      raise TProtocol.TProtocolException(message='Required field partition_spec is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableAddPartitionParams:
  """
  Attributes:
   - if_not_exists
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'if_not_exists', None, None, ), # 1
    (2, TType.LIST, 'partitions', (TType.STRUCT,(TPartitionDef, TPartitionDef.thrift_spec)), None, ), # 2
  )

  def __init__(self, if_not_exists=None, partitions=None,):
    self.if_not_exists = if_not_exists
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = TPartitionDef()
            _elem33.read(iprot)
            self.partitions.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableAddPartitionParams')
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 1)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter34 in self.partitions:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    if self.partitions is None:
      raise TProtocol.TProtocolException(message='Required field partitions is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableAddDropRangePartitionParams:
  """
  Attributes:
   - range_partition_spec
   - ignore_errors
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'range_partition_spec', (CatalogObjects.ttypes.TRangePartition, CatalogObjects.ttypes.TRangePartition.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'ignore_errors', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, range_partition_spec=None, ignore_errors=None, type=None,):
    self.range_partition_spec = range_partition_spec
    self.ignore_errors = ignore_errors
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.range_partition_spec = CatalogObjects.ttypes.TRangePartition()
          self.range_partition_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.ignore_errors = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableAddDropRangePartitionParams')
    if self.range_partition_spec is not None:
      oprot.writeFieldBegin('range_partition_spec', TType.STRUCT, 1)
      self.range_partition_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.ignore_errors is not None:
      oprot.writeFieldBegin('ignore_errors', TType.BOOL, 2)
      oprot.writeBool(self.ignore_errors)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.range_partition_spec is None:
      raise TProtocol.TProtocolException(message='Required field range_partition_spec is unset!')
    if self.ignore_errors is None:
      raise TProtocol.TProtocolException(message='Required field ignore_errors is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableDropColParams:
  """
  Attributes:
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col_name', None, None, ), # 1
  )

  def __init__(self, col_name=None,):
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableDropColParams')
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 1)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.col_name is None:
      raise TProtocol.TProtocolException(message='Required field col_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableDropPartitionParams:
  """
  Attributes:
   - partition_set
   - if_exists
   - purge
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partition_set', (TType.LIST,(TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec))), None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
    (3, TType.BOOL, 'purge', None, None, ), # 3
  )

  def __init__(self, partition_set=None, if_exists=None, purge=None,):
    self.partition_set = partition_set
    self.if_exists = if_exists
    self.purge = purge

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partition_set = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = []
            (_etype44, _size41) = iprot.readListBegin()
            for _i45 in xrange(_size41):
              _elem46 = CatalogObjects.ttypes.TPartitionKeyValue()
              _elem46.read(iprot)
              _elem40.append(_elem46)
            iprot.readListEnd()
            self.partition_set.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.purge = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableDropPartitionParams')
    if self.partition_set is not None:
      oprot.writeFieldBegin('partition_set', TType.LIST, 1)
      oprot.writeListBegin(TType.LIST, len(self.partition_set))
      for iter47 in self.partition_set:
        oprot.writeListBegin(TType.STRUCT, len(iter47))
        for iter48 in iter47:
          iter48.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    if self.purge is not None:
      oprot.writeFieldBegin('purge', TType.BOOL, 3)
      oprot.writeBool(self.purge)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partition_set is None:
      raise TProtocol.TProtocolException(message='Required field partition_set is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    if self.purge is None:
      raise TProtocol.TProtocolException(message='Required field purge is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableAlterColParams:
  """
  Attributes:
   - col_name
   - new_col_def
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col_name', None, None, ), # 1
    (2, TType.STRUCT, 'new_col_def', (CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec), None, ), # 2
  )

  def __init__(self, col_name=None, new_col_def=None,):
    self.col_name = col_name
    self.new_col_def = new_col_def

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.new_col_def = CatalogObjects.ttypes.TColumn()
          self.new_col_def.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableAlterColParams')
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 1)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    if self.new_col_def is not None:
      oprot.writeFieldBegin('new_col_def', TType.STRUCT, 2)
      self.new_col_def.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.col_name is None:
      raise TProtocol.TProtocolException(message='Required field col_name is unset!')
    if self.new_col_def is None:
      raise TProtocol.TProtocolException(message='Required field new_col_def is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetTblPropertiesParams:
  """
  Attributes:
   - target
   - properties
   - partition_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'target', None, None, ), # 1
    (2, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'partition_set', (TType.LIST,(TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec))), None, ), # 3
  )

  def __init__(self, target=None, properties=None, partition_set=None,):
    self.target = target
    self.properties = properties
    self.partition_set = partition_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.target = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype50, _vtype51, _size49 ) = iprot.readMapBegin() 
          for _i53 in xrange(_size49):
            _key54 = iprot.readString();
            _val55 = iprot.readString();
            self.properties[_key54] = _val55
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partition_set = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = []
            (_etype65, _size62) = iprot.readListBegin()
            for _i66 in xrange(_size62):
              _elem67 = CatalogObjects.ttypes.TPartitionKeyValue()
              _elem67.read(iprot)
              _elem61.append(_elem67)
            iprot.readListEnd()
            self.partition_set.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetTblPropertiesParams')
    if self.target is not None:
      oprot.writeFieldBegin('target', TType.I32, 1)
      oprot.writeI32(self.target)
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter68,viter69 in self.properties.items():
        oprot.writeString(kiter68)
        oprot.writeString(viter69)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.partition_set is not None:
      oprot.writeFieldBegin('partition_set', TType.LIST, 3)
      oprot.writeListBegin(TType.LIST, len(self.partition_set))
      for iter70 in self.partition_set:
        oprot.writeListBegin(TType.STRUCT, len(iter70))
        for iter71 in iter70:
          iter71.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.target is None:
      raise TProtocol.TProtocolException(message='Required field target is unset!')
    if self.properties is None:
      raise TProtocol.TProtocolException(message='Required field properties is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetFileFormatParams:
  """
  Attributes:
   - file_format
   - partition_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'file_format', None, None, ), # 1
    (2, TType.LIST, 'partition_set', (TType.LIST,(TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec))), None, ), # 2
  )

  def __init__(self, file_format=None, partition_set=None,):
    self.file_format = file_format
    self.partition_set = partition_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.file_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_set = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = []
            (_etype81, _size78) = iprot.readListBegin()
            for _i82 in xrange(_size78):
              _elem83 = CatalogObjects.ttypes.TPartitionKeyValue()
              _elem83.read(iprot)
              _elem77.append(_elem83)
            iprot.readListEnd()
            self.partition_set.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetFileFormatParams')
    if self.file_format is not None:
      oprot.writeFieldBegin('file_format', TType.I32, 1)
      oprot.writeI32(self.file_format)
      oprot.writeFieldEnd()
    if self.partition_set is not None:
      oprot.writeFieldBegin('partition_set', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.partition_set))
      for iter84 in self.partition_set:
        oprot.writeListBegin(TType.STRUCT, len(iter84))
        for iter85 in iter84:
          iter85.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.file_format is None:
      raise TProtocol.TProtocolException(message='Required field file_format is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetLocationParams:
  """
  Attributes:
   - location
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'location', None, None, ), # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, location=None, partition_spec=None,):
    self.location = location
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype89, _size86) = iprot.readListBegin()
          for _i90 in xrange(_size86):
            _elem91 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem91.read(iprot)
            self.partition_spec.append(_elem91)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetLocationParams')
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 1)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter92 in self.partition_spec:
        iter92.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.location is None:
      raise TProtocol.TProtocolException(message='Required field location is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableUpdateStatsParams:
  """
  Attributes:
   - table_name
   - table_stats
   - partition_stats
   - column_stats
   - expect_all_partitions
   - is_incremental
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'table_stats', (CatalogObjects.ttypes.TTableStats, CatalogObjects.ttypes.TTableStats.thrift_spec), None, ), # 2
    (3, TType.MAP, 'partition_stats', (TType.LIST,(TType.STRING,None),TType.STRUCT,(CatalogObjects.ttypes.TPartitionStats, CatalogObjects.ttypes.TPartitionStats.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'column_stats', (TType.STRING,None,TType.STRUCT,(CatalogObjects.ttypes.TColumnStats, CatalogObjects.ttypes.TColumnStats.thrift_spec)), None, ), # 4
    (5, TType.BOOL, 'expect_all_partitions', None, None, ), # 5
    (6, TType.BOOL, 'is_incremental', None, None, ), # 6
  )

  def __init__(self, table_name=None, table_stats=None, partition_stats=None, column_stats=None, expect_all_partitions=None, is_incremental=None,):
    self.table_name = table_name
    self.table_stats = table_stats
    self.partition_stats = partition_stats
    self.column_stats = column_stats
    self.expect_all_partitions = expect_all_partitions
    self.is_incremental = is_incremental

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_stats = CatalogObjects.ttypes.TTableStats()
          self.table_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.partition_stats = {}
          (_ktype94, _vtype95, _size93 ) = iprot.readMapBegin() 
          for _i97 in xrange(_size93):
            _key98 = []
            (_etype103, _size100) = iprot.readListBegin()
            for _i104 in xrange(_size100):
              _elem105 = iprot.readString();
              _key98.append(_elem105)
            iprot.readListEnd()
            _val99 = CatalogObjects.ttypes.TPartitionStats()
            _val99.read(iprot)
            self.partition_stats[_key98] = _val99
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.column_stats = {}
          (_ktype107, _vtype108, _size106 ) = iprot.readMapBegin() 
          for _i110 in xrange(_size106):
            _key111 = iprot.readString();
            _val112 = CatalogObjects.ttypes.TColumnStats()
            _val112.read(iprot)
            self.column_stats[_key111] = _val112
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.expect_all_partitions = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.is_incremental = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableUpdateStatsParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.table_stats is not None:
      oprot.writeFieldBegin('table_stats', TType.STRUCT, 2)
      self.table_stats.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_stats is not None:
      oprot.writeFieldBegin('partition_stats', TType.MAP, 3)
      oprot.writeMapBegin(TType.LIST, TType.STRUCT, len(self.partition_stats))
      for kiter113,viter114 in self.partition_stats.items():
        oprot.writeListBegin(TType.STRING, len(kiter113))
        for iter115 in kiter113:
          oprot.writeString(iter115)
        oprot.writeListEnd()
        viter114.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.column_stats is not None:
      oprot.writeFieldBegin('column_stats', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.column_stats))
      for kiter116,viter117 in self.column_stats.items():
        oprot.writeString(kiter116)
        viter117.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.expect_all_partitions is not None:
      oprot.writeFieldBegin('expect_all_partitions', TType.BOOL, 5)
      oprot.writeBool(self.expect_all_partitions)
      oprot.writeFieldEnd()
    if self.is_incremental is not None:
      oprot.writeFieldBegin('is_incremental', TType.BOOL, 6)
      oprot.writeBool(self.is_incremental)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetCachedParams:
  """
  Attributes:
   - cache_op
   - partition_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cache_op', (THdfsCachingOp, THdfsCachingOp.thrift_spec), None, ), # 1
    (2, TType.LIST, 'partition_set', (TType.LIST,(TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec))), None, ), # 2
  )

  def __init__(self, cache_op=None, partition_set=None,):
    self.cache_op = cache_op
    self.partition_set = partition_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cache_op = THdfsCachingOp()
          self.cache_op.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_set = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = []
            (_etype127, _size124) = iprot.readListBegin()
            for _i128 in xrange(_size124):
              _elem129 = CatalogObjects.ttypes.TPartitionKeyValue()
              _elem129.read(iprot)
              _elem123.append(_elem129)
            iprot.readListEnd()
            self.partition_set.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetCachedParams')
    if self.cache_op is not None:
      oprot.writeFieldBegin('cache_op', TType.STRUCT, 1)
      self.cache_op.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_set is not None:
      oprot.writeFieldBegin('partition_set', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.partition_set))
      for iter130 in self.partition_set:
        oprot.writeListBegin(TType.STRUCT, len(iter130))
        for iter131 in iter130:
          iter131.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.cache_op is None:
      raise TProtocol.TProtocolException(message='Required field cache_op is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableParams:
  """
  Attributes:
   - alter_type
   - table_name
   - rename_params
   - add_replace_cols_params
   - add_partition_params
   - alter_col_params
   - drop_col_params
   - drop_partition_params
   - set_file_format_params
   - set_location_params
   - set_tbl_properties_params
   - update_stats_params
   - set_cached_params
   - add_drop_range_partition_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'alter_type', None, None, ), # 1
    (2, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'rename_params', (TAlterTableOrViewRenameParams, TAlterTableOrViewRenameParams.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'add_replace_cols_params', (TAlterTableAddReplaceColsParams, TAlterTableAddReplaceColsParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'add_partition_params', (TAlterTableAddPartitionParams, TAlterTableAddPartitionParams.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'alter_col_params', (TAlterTableAlterColParams, TAlterTableAlterColParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'drop_col_params', (TAlterTableDropColParams, TAlterTableDropColParams.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'drop_partition_params', (TAlterTableDropPartitionParams, TAlterTableDropPartitionParams.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'set_file_format_params', (TAlterTableSetFileFormatParams, TAlterTableSetFileFormatParams.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'set_location_params', (TAlterTableSetLocationParams, TAlterTableSetLocationParams.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'set_tbl_properties_params', (TAlterTableSetTblPropertiesParams, TAlterTableSetTblPropertiesParams.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'update_stats_params', (TAlterTableUpdateStatsParams, TAlterTableUpdateStatsParams.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'set_cached_params', (TAlterTableSetCachedParams, TAlterTableSetCachedParams.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'add_drop_range_partition_params', (TAlterTableAddDropRangePartitionParams, TAlterTableAddDropRangePartitionParams.thrift_spec), None, ), # 14
  )

  def __init__(self, alter_type=None, table_name=None, rename_params=None, add_replace_cols_params=None, add_partition_params=None, alter_col_params=None, drop_col_params=None, drop_partition_params=None, set_file_format_params=None, set_location_params=None, set_tbl_properties_params=None, update_stats_params=None, set_cached_params=None, add_drop_range_partition_params=None,):
    self.alter_type = alter_type
    self.table_name = table_name
    self.rename_params = rename_params
    self.add_replace_cols_params = add_replace_cols_params
    self.add_partition_params = add_partition_params
    self.alter_col_params = alter_col_params
    self.drop_col_params = drop_col_params
    self.drop_partition_params = drop_partition_params
    self.set_file_format_params = set_file_format_params
    self.set_location_params = set_location_params
    self.set_tbl_properties_params = set_tbl_properties_params
    self.update_stats_params = update_stats_params
    self.set_cached_params = set_cached_params
    self.add_drop_range_partition_params = add_drop_range_partition_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.alter_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.rename_params = TAlterTableOrViewRenameParams()
          self.rename_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.add_replace_cols_params = TAlterTableAddReplaceColsParams()
          self.add_replace_cols_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.add_partition_params = TAlterTableAddPartitionParams()
          self.add_partition_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.alter_col_params = TAlterTableAlterColParams()
          self.alter_col_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.drop_col_params = TAlterTableDropColParams()
          self.drop_col_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.drop_partition_params = TAlterTableDropPartitionParams()
          self.drop_partition_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.set_file_format_params = TAlterTableSetFileFormatParams()
          self.set_file_format_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.set_location_params = TAlterTableSetLocationParams()
          self.set_location_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.set_tbl_properties_params = TAlterTableSetTblPropertiesParams()
          self.set_tbl_properties_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.update_stats_params = TAlterTableUpdateStatsParams()
          self.update_stats_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.set_cached_params = TAlterTableSetCachedParams()
          self.set_cached_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.add_drop_range_partition_params = TAlterTableAddDropRangePartitionParams()
          self.add_drop_range_partition_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableParams')
    if self.alter_type is not None:
      oprot.writeFieldBegin('alter_type', TType.I32, 1)
      oprot.writeI32(self.alter_type)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.rename_params is not None:
      oprot.writeFieldBegin('rename_params', TType.STRUCT, 3)
      self.rename_params.write(oprot)
      oprot.writeFieldEnd()
    if self.add_replace_cols_params is not None:
      oprot.writeFieldBegin('add_replace_cols_params', TType.STRUCT, 4)
      self.add_replace_cols_params.write(oprot)
      oprot.writeFieldEnd()
    if self.add_partition_params is not None:
      oprot.writeFieldBegin('add_partition_params', TType.STRUCT, 5)
      self.add_partition_params.write(oprot)
      oprot.writeFieldEnd()
    if self.alter_col_params is not None:
      oprot.writeFieldBegin('alter_col_params', TType.STRUCT, 6)
      self.alter_col_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_col_params is not None:
      oprot.writeFieldBegin('drop_col_params', TType.STRUCT, 7)
      self.drop_col_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_partition_params is not None:
      oprot.writeFieldBegin('drop_partition_params', TType.STRUCT, 8)
      self.drop_partition_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_file_format_params is not None:
      oprot.writeFieldBegin('set_file_format_params', TType.STRUCT, 9)
      self.set_file_format_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_location_params is not None:
      oprot.writeFieldBegin('set_location_params', TType.STRUCT, 10)
      self.set_location_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_tbl_properties_params is not None:
      oprot.writeFieldBegin('set_tbl_properties_params', TType.STRUCT, 11)
      self.set_tbl_properties_params.write(oprot)
      oprot.writeFieldEnd()
    if self.update_stats_params is not None:
      oprot.writeFieldBegin('update_stats_params', TType.STRUCT, 12)
      self.update_stats_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_cached_params is not None:
      oprot.writeFieldBegin('set_cached_params', TType.STRUCT, 13)
      self.set_cached_params.write(oprot)
      oprot.writeFieldEnd()
    if self.add_drop_range_partition_params is not None:
      oprot.writeFieldBegin('add_drop_range_partition_params', TType.STRUCT, 14)
      self.add_drop_range_partition_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.alter_type is None:
      raise TProtocol.TProtocolException(message='Required field alter_type is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateTableLikeParams:
  """
  Attributes:
   - table_name
   - src_table_name
   - is_external
   - if_not_exists
   - owner
   - file_format
   - comment
   - location
   - sort_columns
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'src_table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'is_external', None, None, ), # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ), # 4
    (5, TType.STRING, 'owner', None, None, ), # 5
    (6, TType.I32, 'file_format', None, None, ), # 6
    (7, TType.STRING, 'comment', None, None, ), # 7
    (8, TType.STRING, 'location', None, None, ), # 8
    (9, TType.LIST, 'sort_columns', (TType.STRING,None), None, ), # 9
  )

  def __init__(self, table_name=None, src_table_name=None, is_external=None, if_not_exists=None, owner=None, file_format=None, comment=None, location=None, sort_columns=None,):
    self.table_name = table_name
    self.src_table_name = src_table_name
    self.is_external = is_external
    self.if_not_exists = if_not_exists
    self.owner = owner
    self.file_format = file_format
    self.comment = comment
    self.location = location
    self.sort_columns = sort_columns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.src_table_name = CatalogObjects.ttypes.TTableName()
          self.src_table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_external = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.file_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.sort_columns = []
          (_etype135, _size132) = iprot.readListBegin()
          for _i136 in xrange(_size132):
            _elem137 = iprot.readString();
            self.sort_columns.append(_elem137)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateTableLikeParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.src_table_name is not None:
      oprot.writeFieldBegin('src_table_name', TType.STRUCT, 2)
      self.src_table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.is_external is not None:
      oprot.writeFieldBegin('is_external', TType.BOOL, 3)
      oprot.writeBool(self.is_external)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 5)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.file_format is not None:
      oprot.writeFieldBegin('file_format', TType.I32, 6)
      oprot.writeI32(self.file_format)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 7)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 8)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.sort_columns is not None:
      oprot.writeFieldBegin('sort_columns', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.sort_columns))
      for iter138 in self.sort_columns:
        oprot.writeString(iter138)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.src_table_name is None:
      raise TProtocol.TProtocolException(message='Required field src_table_name is unset!')
    if self.is_external is None:
      raise TProtocol.TProtocolException(message='Required field is_external is unset!')
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    if self.owner is None:
      raise TProtocol.TProtocolException(message='Required field owner is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateTableParams:
  """
  Attributes:
   - table_name
   - columns
   - partition_columns
   - file_format
   - is_external
   - if_not_exists
   - owner
   - row_format
   - comment
   - location
   - table_properties
   - serde_properties
   - cache_op
   - partition_by
   - primary_key_column_names
   - sort_columns
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'partition_columns', (TType.STRUCT,(CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec)), None, ), # 3
    (4, TType.I32, 'file_format', None, None, ), # 4
    (5, TType.BOOL, 'is_external', None, None, ), # 5
    (6, TType.BOOL, 'if_not_exists', None, None, ), # 6
    (7, TType.STRING, 'owner', None, None, ), # 7
    (8, TType.STRUCT, 'row_format', (TTableRowFormat, TTableRowFormat.thrift_spec), None, ), # 8
    (9, TType.STRING, 'comment', None, None, ), # 9
    (10, TType.STRING, 'location', None, None, ), # 10
    (11, TType.MAP, 'table_properties', (TType.STRING,None,TType.STRING,None), None, ), # 11
    (12, TType.MAP, 'serde_properties', (TType.STRING,None,TType.STRING,None), None, ), # 12
    (13, TType.STRUCT, 'cache_op', (THdfsCachingOp, THdfsCachingOp.thrift_spec), None, ), # 13
    (14, TType.LIST, 'partition_by', (TType.STRUCT,(CatalogObjects.ttypes.TKuduPartitionParam, CatalogObjects.ttypes.TKuduPartitionParam.thrift_spec)), None, ), # 14
    (15, TType.LIST, 'primary_key_column_names', (TType.STRING,None), None, ), # 15
    (16, TType.LIST, 'sort_columns', (TType.STRING,None), None, ), # 16
  )

  def __init__(self, table_name=None, columns=None, partition_columns=None, file_format=None, is_external=None, if_not_exists=None, owner=None, row_format=None, comment=None, location=None, table_properties=None, serde_properties=None, cache_op=None, partition_by=None, primary_key_column_names=None, sort_columns=None,):
    self.table_name = table_name
    self.columns = columns
    self.partition_columns = partition_columns
    self.file_format = file_format
    self.is_external = is_external
    self.if_not_exists = if_not_exists
    self.owner = owner
    self.row_format = row_format
    self.comment = comment
    self.location = location
    self.table_properties = table_properties
    self.serde_properties = serde_properties
    self.cache_op = cache_op
    self.partition_by = partition_by
    self.primary_key_column_names = primary_key_column_names
    self.sort_columns = sort_columns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype142, _size139) = iprot.readListBegin()
          for _i143 in xrange(_size139):
            _elem144 = CatalogObjects.ttypes.TColumn()
            _elem144.read(iprot)
            self.columns.append(_elem144)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partition_columns = []
          (_etype148, _size145) = iprot.readListBegin()
          for _i149 in xrange(_size145):
            _elem150 = CatalogObjects.ttypes.TColumn()
            _elem150.read(iprot)
            self.partition_columns.append(_elem150)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.file_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_external = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.row_format = TTableRowFormat()
          self.row_format.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.table_properties = {}
          (_ktype152, _vtype153, _size151 ) = iprot.readMapBegin() 
          for _i155 in xrange(_size151):
            _key156 = iprot.readString();
            _val157 = iprot.readString();
            self.table_properties[_key156] = _val157
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.MAP:
          self.serde_properties = {}
          (_ktype159, _vtype160, _size158 ) = iprot.readMapBegin() 
          for _i162 in xrange(_size158):
            _key163 = iprot.readString();
            _val164 = iprot.readString();
            self.serde_properties[_key163] = _val164
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.cache_op = THdfsCachingOp()
          self.cache_op.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.partition_by = []
          (_etype168, _size165) = iprot.readListBegin()
          for _i169 in xrange(_size165):
            _elem170 = CatalogObjects.ttypes.TKuduPartitionParam()
            _elem170.read(iprot)
            self.partition_by.append(_elem170)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.primary_key_column_names = []
          (_etype174, _size171) = iprot.readListBegin()
          for _i175 in xrange(_size171):
            _elem176 = iprot.readString();
            self.primary_key_column_names.append(_elem176)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.sort_columns = []
          (_etype180, _size177) = iprot.readListBegin()
          for _i181 in xrange(_size177):
            _elem182 = iprot.readString();
            self.sort_columns.append(_elem182)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateTableParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter183 in self.columns:
        iter183.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partition_columns is not None:
      oprot.writeFieldBegin('partition_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_columns))
      for iter184 in self.partition_columns:
        iter184.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.file_format is not None:
      oprot.writeFieldBegin('file_format', TType.I32, 4)
      oprot.writeI32(self.file_format)
      oprot.writeFieldEnd()
    if self.is_external is not None:
      oprot.writeFieldBegin('is_external', TType.BOOL, 5)
      oprot.writeBool(self.is_external)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 6)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 7)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.row_format is not None:
      oprot.writeFieldBegin('row_format', TType.STRUCT, 8)
      self.row_format.write(oprot)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 9)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 10)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.table_properties is not None:
      oprot.writeFieldBegin('table_properties', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.table_properties))
      for kiter185,viter186 in self.table_properties.items():
        oprot.writeString(kiter185)
        oprot.writeString(viter186)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.serde_properties is not None:
      oprot.writeFieldBegin('serde_properties', TType.MAP, 12)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.serde_properties))
      for kiter187,viter188 in self.serde_properties.items():
        oprot.writeString(kiter187)
        oprot.writeString(viter188)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.cache_op is not None:
      oprot.writeFieldBegin('cache_op', TType.STRUCT, 13)
      self.cache_op.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_by is not None:
      oprot.writeFieldBegin('partition_by', TType.LIST, 14)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_by))
      for iter189 in self.partition_by:
        iter189.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.primary_key_column_names is not None:
      oprot.writeFieldBegin('primary_key_column_names', TType.LIST, 15)
      oprot.writeListBegin(TType.STRING, len(self.primary_key_column_names))
      for iter190 in self.primary_key_column_names:
        oprot.writeString(iter190)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sort_columns is not None:
      oprot.writeFieldBegin('sort_columns', TType.LIST, 16)
      oprot.writeListBegin(TType.STRING, len(self.sort_columns))
      for iter191 in self.sort_columns:
        oprot.writeString(iter191)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.file_format is None:
      raise TProtocol.TProtocolException(message='Required field file_format is unset!')
    if self.is_external is None:
      raise TProtocol.TProtocolException(message='Required field is_external is unset!')
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    if self.owner is None:
      raise TProtocol.TProtocolException(message='Required field owner is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateOrAlterViewParams:
  """
  Attributes:
   - view_name
   - columns
   - owner
   - original_view_def
   - expanded_view_def
   - comment
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'view_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'owner', None, None, ), # 3
    (4, TType.STRING, 'original_view_def', None, None, ), # 4
    (5, TType.STRING, 'expanded_view_def', None, None, ), # 5
    (6, TType.STRING, 'comment', None, None, ), # 6
    (7, TType.BOOL, 'if_not_exists', None, None, ), # 7
  )

  def __init__(self, view_name=None, columns=None, owner=None, original_view_def=None, expanded_view_def=None, comment=None, if_not_exists=None,):
    self.view_name = view_name
    self.columns = columns
    self.owner = owner
    self.original_view_def = original_view_def
    self.expanded_view_def = expanded_view_def
    self.comment = comment
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.view_name = CatalogObjects.ttypes.TTableName()
          self.view_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype195, _size192) = iprot.readListBegin()
          for _i196 in xrange(_size192):
            _elem197 = CatalogObjects.ttypes.TColumn()
            _elem197.read(iprot)
            self.columns.append(_elem197)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.original_view_def = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.expanded_view_def = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateOrAlterViewParams')
    if self.view_name is not None:
      oprot.writeFieldBegin('view_name', TType.STRUCT, 1)
      self.view_name.write(oprot)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter198 in self.columns:
        iter198.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 3)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.original_view_def is not None:
      oprot.writeFieldBegin('original_view_def', TType.STRING, 4)
      oprot.writeString(self.original_view_def)
      oprot.writeFieldEnd()
    if self.expanded_view_def is not None:
      oprot.writeFieldBegin('expanded_view_def', TType.STRING, 5)
      oprot.writeString(self.expanded_view_def)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 6)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 7)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.view_name is None:
      raise TProtocol.TProtocolException(message='Required field view_name is unset!')
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.owner is None:
      raise TProtocol.TProtocolException(message='Required field owner is unset!')
    if self.original_view_def is None:
      raise TProtocol.TProtocolException(message='Required field original_view_def is unset!')
    if self.expanded_view_def is None:
      raise TProtocol.TProtocolException(message='Required field expanded_view_def is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TComputeStatsParams:
  """
  Attributes:
   - table_name
   - tbl_stats_query
   - col_stats_query
   - is_incremental
   - existing_part_stats
   - expected_partitions
   - expect_all_partitions
   - num_partition_cols
   - total_file_bytes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.STRING, 'tbl_stats_query', None, None, ), # 2
    (3, TType.STRING, 'col_stats_query', None, None, ), # 3
    (4, TType.BOOL, 'is_incremental', None, None, ), # 4
    (5, TType.LIST, 'existing_part_stats', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionStats, CatalogObjects.ttypes.TPartitionStats.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'expected_partitions', (TType.LIST,(TType.STRING,None)), None, ), # 6
    (7, TType.BOOL, 'expect_all_partitions', None, None, ), # 7
    (8, TType.I32, 'num_partition_cols', None, None, ), # 8
    (9, TType.I64, 'total_file_bytes', None, None, ), # 9
  )

  def __init__(self, table_name=None, tbl_stats_query=None, col_stats_query=None, is_incremental=None, existing_part_stats=None, expected_partitions=None, expect_all_partitions=None, num_partition_cols=None, total_file_bytes=None,):
    self.table_name = table_name
    self.tbl_stats_query = tbl_stats_query
    self.col_stats_query = col_stats_query
    self.is_incremental = is_incremental
    self.existing_part_stats = existing_part_stats
    self.expected_partitions = expected_partitions
    self.expect_all_partitions = expect_all_partitions
    self.num_partition_cols = num_partition_cols
    self.total_file_bytes = total_file_bytes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_stats_query = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.col_stats_query = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_incremental = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.existing_part_stats = []
          (_etype202, _size199) = iprot.readListBegin()
          for _i203 in xrange(_size199):
            _elem204 = CatalogObjects.ttypes.TPartitionStats()
            _elem204.read(iprot)
            self.existing_part_stats.append(_elem204)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.expected_partitions = []
          (_etype208, _size205) = iprot.readListBegin()
          for _i209 in xrange(_size205):
            _elem210 = []
            (_etype214, _size211) = iprot.readListBegin()
            for _i215 in xrange(_size211):
              _elem216 = iprot.readString();
              _elem210.append(_elem216)
            iprot.readListEnd()
            self.expected_partitions.append(_elem210)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.expect_all_partitions = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.num_partition_cols = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.total_file_bytes = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TComputeStatsParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl_stats_query is not None:
      oprot.writeFieldBegin('tbl_stats_query', TType.STRING, 2)
      oprot.writeString(self.tbl_stats_query)
      oprot.writeFieldEnd()
    if self.col_stats_query is not None:
      oprot.writeFieldBegin('col_stats_query', TType.STRING, 3)
      oprot.writeString(self.col_stats_query)
      oprot.writeFieldEnd()
    if self.is_incremental is not None:
      oprot.writeFieldBegin('is_incremental', TType.BOOL, 4)
      oprot.writeBool(self.is_incremental)
      oprot.writeFieldEnd()
    if self.existing_part_stats is not None:
      oprot.writeFieldBegin('existing_part_stats', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.existing_part_stats))
      for iter217 in self.existing_part_stats:
        iter217.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expected_partitions is not None:
      oprot.writeFieldBegin('expected_partitions', TType.LIST, 6)
      oprot.writeListBegin(TType.LIST, len(self.expected_partitions))
      for iter218 in self.expected_partitions:
        oprot.writeListBegin(TType.STRING, len(iter218))
        for iter219 in iter218:
          oprot.writeString(iter219)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expect_all_partitions is not None:
      oprot.writeFieldBegin('expect_all_partitions', TType.BOOL, 7)
      oprot.writeBool(self.expect_all_partitions)
      oprot.writeFieldEnd()
    if self.num_partition_cols is not None:
      oprot.writeFieldBegin('num_partition_cols', TType.I32, 8)
      oprot.writeI32(self.num_partition_cols)
      oprot.writeFieldEnd()
    if self.total_file_bytes is not None:
      oprot.writeFieldBegin('total_file_bytes', TType.I64, 9)
      oprot.writeI64(self.total_file_bytes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateDropRoleParams:
  """
  Attributes:
   - is_drop
   - role_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_drop', None, None, ), # 1
    (2, TType.STRING, 'role_name', None, None, ), # 2
  )

  def __init__(self, is_drop=None, role_name=None,):
    self.is_drop = is_drop
    self.role_name = role_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_drop = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateDropRoleParams')
    if self.is_drop is not None:
      oprot.writeFieldBegin('is_drop', TType.BOOL, 1)
      oprot.writeBool(self.is_drop)
      oprot.writeFieldEnd()
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 2)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_drop is None:
      raise TProtocol.TProtocolException(message='Required field is_drop is unset!')
    if self.role_name is None:
      raise TProtocol.TProtocolException(message='Required field role_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGrantRevokeRoleParams:
  """
  Attributes:
   - role_names
   - group_names
   - is_grant
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'role_names', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 2
    (3, TType.BOOL, 'is_grant', None, None, ), # 3
  )

  def __init__(self, role_names=None, group_names=None, is_grant=None,):
    self.role_names = role_names
    self.group_names = group_names
    self.is_grant = is_grant

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.role_names = []
          (_etype223, _size220) = iprot.readListBegin()
          for _i224 in xrange(_size220):
            _elem225 = iprot.readString();
            self.role_names.append(_elem225)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype229, _size226) = iprot.readListBegin()
          for _i230 in xrange(_size226):
            _elem231 = iprot.readString();
            self.group_names.append(_elem231)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_grant = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGrantRevokeRoleParams')
    if self.role_names is not None:
      oprot.writeFieldBegin('role_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.role_names))
      for iter232 in self.role_names:
        oprot.writeString(iter232)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter233 in self.group_names:
        oprot.writeString(iter233)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_grant is not None:
      oprot.writeFieldBegin('is_grant', TType.BOOL, 3)
      oprot.writeBool(self.is_grant)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.role_names is None:
      raise TProtocol.TProtocolException(message='Required field role_names is unset!')
    if self.group_names is None:
      raise TProtocol.TProtocolException(message='Required field group_names is unset!')
    if self.is_grant is None:
      raise TProtocol.TProtocolException(message='Required field is_grant is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGrantRevokePrivParams:
  """
  Attributes:
   - privileges
   - role_name
   - is_grant
   - has_grant_opt
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT,(CatalogObjects.ttypes.TPrivilege, CatalogObjects.ttypes.TPrivilege.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'role_name', None, None, ), # 2
    (3, TType.BOOL, 'is_grant', None, None, ), # 3
    (4, TType.BOOL, 'has_grant_opt', None, None, ), # 4
  )

  def __init__(self, privileges=None, role_name=None, is_grant=None, has_grant_opt=None,):
    self.privileges = privileges
    self.role_name = role_name
    self.is_grant = is_grant
    self.has_grant_opt = has_grant_opt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.privileges = []
          (_etype237, _size234) = iprot.readListBegin()
          for _i238 in xrange(_size234):
            _elem239 = CatalogObjects.ttypes.TPrivilege()
            _elem239.read(iprot)
            self.privileges.append(_elem239)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_grant = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.has_grant_opt = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGrantRevokePrivParams')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.privileges))
      for iter240 in self.privileges:
        iter240.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 2)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.is_grant is not None:
      oprot.writeFieldBegin('is_grant', TType.BOOL, 3)
      oprot.writeBool(self.is_grant)
      oprot.writeFieldEnd()
    if self.has_grant_opt is not None:
      oprot.writeFieldBegin('has_grant_opt', TType.BOOL, 4)
      oprot.writeBool(self.has_grant_opt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.privileges is None:
      raise TProtocol.TProtocolException(message='Required field privileges is unset!')
    if self.role_name is None:
      raise TProtocol.TProtocolException(message='Required field role_name is unset!')
    if self.is_grant is None:
      raise TProtocol.TProtocolException(message='Required field is_grant is unset!')
    if self.has_grant_opt is None:
      raise TProtocol.TProtocolException(message='Required field has_grant_opt is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropDbParams:
  """
  Attributes:
   - db
   - if_exists
   - cascade
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
    (3, TType.BOOL, 'cascade', None, None, ), # 3
  )

  def __init__(self, db=None, if_exists=None, cascade=None,):
    self.db = db
    self.if_exists = if_exists
    self.cascade = cascade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.cascade = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    if self.cascade is not None:
      oprot.writeFieldBegin('cascade', TType.BOOL, 3)
      oprot.writeBool(self.cascade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    if self.cascade is None:
      raise TProtocol.TProtocolException(message='Required field cascade is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropTableOrViewParams:
  """
  Attributes:
   - table_name
   - if_exists
   - purge
   - is_table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
    (3, TType.BOOL, 'purge', None, None, ), # 3
    (4, TType.BOOL, 'is_table', None, None, ), # 4
  )

  def __init__(self, table_name=None, if_exists=None, purge=None, is_table=None,):
    self.table_name = table_name
    self.if_exists = if_exists
    self.purge = purge
    self.is_table = is_table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.purge = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_table = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropTableOrViewParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    if self.purge is not None:
      oprot.writeFieldBegin('purge', TType.BOOL, 3)
      oprot.writeBool(self.purge)
      oprot.writeFieldEnd()
    if self.is_table is not None:
      oprot.writeFieldBegin('is_table', TType.BOOL, 4)
      oprot.writeBool(self.is_table)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    if self.purge is None:
      raise TProtocol.TProtocolException(message='Required field purge is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTruncateParams:
  """
  Attributes:
   - table_name
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, table_name=None, if_exists=None,):
    self.table_name = table_name
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTruncateParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropFunctionParams:
  """
  Attributes:
   - fn_name
   - arg_types
   - if_exists
   - signature
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fn_name', (Types.ttypes.TFunctionName, Types.ttypes.TFunctionName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'arg_types', (TType.STRUCT,(Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec)), None, ), # 2
    (3, TType.BOOL, 'if_exists', None, None, ), # 3
    (4, TType.STRING, 'signature', None, None, ), # 4
  )

  def __init__(self, fn_name=None, arg_types=None, if_exists=None, signature=None,):
    self.fn_name = fn_name
    self.arg_types = arg_types
    self.if_exists = if_exists
    self.signature = signature

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fn_name = Types.ttypes.TFunctionName()
          self.fn_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.arg_types = []
          (_etype244, _size241) = iprot.readListBegin()
          for _i245 in xrange(_size241):
            _elem246 = Types.ttypes.TColumnType()
            _elem246.read(iprot)
            self.arg_types.append(_elem246)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.signature = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropFunctionParams')
    if self.fn_name is not None:
      oprot.writeFieldBegin('fn_name', TType.STRUCT, 1)
      self.fn_name.write(oprot)
      oprot.writeFieldEnd()
    if self.arg_types is not None:
      oprot.writeFieldBegin('arg_types', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
      for iter247 in self.arg_types:
        iter247.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    if self.signature is not None:
      oprot.writeFieldBegin('signature', TType.STRING, 4)
      oprot.writeString(self.signature)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fn_name is None:
      raise TProtocol.TProtocolException(message='Required field fn_name is unset!')
    if self.arg_types is None:
      raise TProtocol.TProtocolException(message='Required field arg_types is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
